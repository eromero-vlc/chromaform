#!/bin/bash

## Ultimate script to install chroma ecosystem
##

read -r -d '' hlp_msg << 'EOF'
Script for installing chroma and redstar and related software.

chromaform [--source-dir=dir] [--build-dir=dir] [--install-dir=dir]                       \\
           [--float] [--cuda|--hip] [--mg] [--pdf] [--next] [--superb]                    \\
           [--cmake=build|--cmake=system] [--llvm=build|--llvm=system]                    \\
           [--thrust=build|--thrust=system] [--gmp=build|--gmp=system]                    \\
           [--libxml2=build|--libxml2=system] [--tinfo=build|--tinfo=system]              \\
           [--blas=openblas|--blas=openblas-system|--blas=atlas-system|--blas=mkl]        \\
           [-g|-O|-Onone] [--avx|--avx2|--knl|--avx512|--zen2|--zen3] [--autoflags=no]    \\
           [--std=c++11|--std=c++14|--std=c++17|--std=c++20]                              \\
           [--clean|--install|--update|--download-only] [gcc] [openmpi] [mvapich2]        \\
           [cmake] [llvm] [automake] [cub] [thrust] [openblas] [gmp] [libxml2] [eigen]    \\
           [ncurses] [libfuse3] [anarchofs]                                               \\
           [qmp] [qdp] [superbblas] [primme] [magma] [mgproto] [qphix] [quda] [chroma]    \\
           [laplace_eigs] [adat] [colorvec] [tensor] [hadron] [redstar]                   \\
           [CC=...] [CFLAGS=...] [CXX=...] [CXXFLAGS=...] [FC=...] [SM=...]               \\
           [CMAKE_EXTRA_FLAGS=...]

Examples:

# Install chroma with mg_proto/QPhiX
chromaform --mg chroma
# Install chroma with mg_proto/QPhiX with AVX512 support
chromaform --mg --avx512 chroma
# Install chroma with QUDA for arch=sm_70
chromaform --mg --cuda chroma SM=sm_70
# Install redstar and harom
chromaform redstar harom

* Location options:
Each installed package will have an entry in the directories indicated
for keeping the source, the compilation, and the installation. 

--source-dir=<dir> 
   Directory where to put the sources; the default is \$PWD/src.
--build-dir=<dir>
   Directory where to build the packages; the default is \$PWD/build.
--install-dir=<dir>
   Directory where to install the packages; the default is \$PWD/install.

* Package flavor options:
Some packages have special optional features.

--float
   Install the single-precision version; the double precision version is installed
   by default. Used by QDP.
--cuda
   Install the CUDA/JIT version; the CPU version is installed by default. Used by QDP,
   superbblas, and chroma.
--hip
   Install the HIP/JIT version; the CPU version is installed by default. Used by QDP,
   superbblas, and chroma.
--mg
   Install multigrid extension of chroma; it isn't installed by default.
--superb
   Install the superbblas extensions of chroma; it isn't installed by default.
--pdf
   Install the devel-pdf branches of adat, colorvec and redstar; the devel branch is
   installed by default.
--next
   Install upcoming versions of some packages; the version in devel or master is
   installed by default. Used by:
   - chroma: new disconnected diagram task based on frequency splitting.
   - adat/colorvec/redstar: phasing support and new keys for correlation functions,
     branch `eloy/mix-phasings-with-momclass`.
--meta
   Install the devel-meta version of hadron.


* CMake, LLVM, BLAS, GMP, LIBXML2:
   Some packages require CMake, LLVM, and BLAS, and this are the options to select
   which implementation to use.

--cmake=[build|system]
   Use the cmake in \$PATH if 'system' is given; otherwise, it builds a recent version.
   By default, it detects the cmake version available, and build cmake if it is not
   recent enough.

--llvm=[build|system]
   Use the LLVM indicated by llvm-config  in \$PATH if 'system' is given; otherwise, it
   builds a recent version. By default, it detects the LLVM version available, and build 
   LLVM if it is not.

--thrust=[build|system]
   Use the cub/thrust in the CUDA SDK if 'system' is given; otherwise, it
   downloads a recent version. By default, it detects the thrust version available, and
   download cub and thrust if it is not.

--blas=[openblas|openblas-system|atlas-system|mkl]
   Build OpenBLAS if 'openblas' is given, or use the system OpenBLAS, ATLAS, or MKL if
   'openblas-system', 'atlas-system', 'mkl' is given, respectively. If using MKL, plase
   set the environ variable MKLROOT. By default, it detects if there are flags in LDFLAGS
   and LIBS suggesting the use of MKL, OpenBLAS, and ATLAS, and use that. Otherwise, it
   uses MKL if MKLROOT is set, or OpenBLAS or ATLAS if they have pkg-config sets
   available.

--gmp=[build|system]
   Use the qmp in the system if 'system' is given; otherwise, it
   downloads a recent version. By default, it detects if they have pkg-config
   configuration available.

--libxml2=[build|system]
   Use the libxml2 in the system if 'system' is given; otherwise, it
   downloads a recent version. By default, it detects if they have pkg-config
   configuration available.

* Compilation flags:
Control the flags use for building the packages.

-g|-O|-Onone
   Append '-g3 -O0' to CFLAGS and CXXFLAGS if '-g' is given, of '-O3' if '-O' is given, 
   or no flags are added if '-Onone' is given. By default, '-O3' is appended.

--avx|--avx2|--knl|--avx512|--zen2|--zen3
   Append flags in CFLAGS and CXXFLAGS to activate proper extensions in the compiler,
   and set the QphiX isa.

--std=c++11|c++14|C++17|c++20   
   Append the given flag to CXXFLAGS; --std=c++20 is appended if flag '--hip' or ---cuda'
   is set; otherwise, --std=c++14 is appended by default.

--autoflags=no
   If given, CFLAGS, CXXFLAGS, and LDFLAGS are not modified by the options -g, -O,
   --avx512, --knl, --zen2, --zen3, and --std, or any automatic heuristic in this script.
   By default, besides setting CFLAGS and CXXFLAGS as described, flags are added to
   activate AVX2 and OpenMP compiler extensions.

* Actions and packages:
An action is either of the flags --clean, --install, or --update, and can be followed by
several packages and other actions. The --update action is implied if no other action was
given before. For instance:

  chromaform chroma --install openblas

marks the package chroma with the flag --update and the package openblas with the flag
--install. The actions are described in the following:

--install <pkg> <pkg> ...
   Always download the source code, build, and install the packages marked with this
   action. Mark their dependent packages as --update.
--update <pkg> <pkg> ...
   Download the source code if it is not in the source directory already, and install the
   packages marked with this action if they are not found on the install directory.
   Mark their dependent packages as --update.
--clean <pkg> <pkg> ...
   Remove the instances in the source, build, and install directories of the packages
   marked with this action.

--download-only
   If given, no building nor installation is done, only changes on the source directory
   are going to be performed. This is useful to download all the sources required and
   copy them to a machine without external internet access. 

* Set environ variables:
All input options that are not flags or packages described above and contain '='
will be considered a variable assignation. For instance:

  chromaform chroma CC=icc CXX=icpc PATH=/mypaths:\$PATH

will export the value of the variables CC, CXX, and PATH to subshells and executed
commands.
EOF

srcdir="src"
builddir="build"
installdir="install"
download_only="nop"
do_cleaning="nop"
use_float="nop"
use_arch="cpu"
use_march=""
use_pdf="nop"
use_pdf_next="nop"
use_meta="nop"
use_next="nop"
use_restructure="nop"
use_superb="nop"
use_qdpjit=""
use_superb_next="nop"
use_mg="nop"
use_llvm=""
use_thrust=""
use_blas=""
use_gmp=""
use_libxml2=""
use_libfuse3=""
use_tinfo=""
use_cmake=""
use_mpi="duno"
use_openmp=""
use_autoflags="yes"
use_opt="opt"
use_std=""
openblas_use_gcc=""
do_export_env=""
action="update"

# Jean Zay's frontend does not have much memory and chroma linking fails often
mymake() {
	make "$@" || make "$@" -j 1 || make "$@" -j 1 || make "$@" -j 1 
}

# Detect python3

if [ x${PYTHON} == x ]; then
	if python3 --version 2>&1 | grep -q "Python 3" ; then
		PYTHON="python3"
	elif python --version 2>&1 | grep -q "Python 3" ; then
		PYTHON="python"
	fi
fi

MYMAKE="${MAKE:-mymake}"
if [ x${MAKE_JN}x == xx ]; then
	if [ -r /proc/cpuinfo ]; then
		MAKE_JN="$(( (`grep "^processor" /proc/cpuinfo | wc -l` + 2) / 3 ))"
	elif command -v sysctl &> /dev/null ; then
		MAKE_JN="$( sysctl -n hw.ncpu 2> /dev/null )"
	elif command -v getconf &> /dev/null ; then
		MAKE_JN="$( getconf _NPROCESSORS_ONLN 2> /dev/null )"
	elif command -v ${PYTHON} &> /dev/null ; then
		MAKE_JN="$( ${PYTHON} - << 'EOF'
import multiprocessing
print(multiprocessing.cpu_count() or 1)
EOF
)"
	else
		MAKE_JN=1
	fi
fi
case "$MAKE_JN" in
""|*[!0-9]*) MAKE_JN=1 ;;
0) MAKE_JN=1 ;;
esac
export MAKE_JN
if [ x${CUDADIR}x == xx ] ; then
	CUDADIR="$( realpath $( dirname $( which nvcc ))/..)"
	# If using NVHPC, point out the cuda directory
	if [ x${CUDADIR}x != x${CUDADIR%compilers}x ] ; then
		CUDADIR="$( realpath ${CUDADIR}/../cuda )"
		CUDADIR_extra="$( realpath ${CUDADIR}/../math_libs )"
	fi
fi
SM="${SM:-sm_70}"
AMDGPU_TARGETS="${AMDGPU_TARGETS:-gfx900;gfx906;gfx908}"
tmp="`mktemp -d`"
idir=""

finish() {
	rm -rf $tmp
	# If a make install failed in the middle, remove the whole directory
	[ x${idir}x != xx ] && rm -rf $idir
}
trap finish EXIT

n=$#
for (( i=1 ; i<=n ; ++i )); do
	arg="$1"
	case $arg in
	--source-dir=*) srcdir="${arg#--source-dir=}";;
	--build-dir=*) builddir="${arg#--build-dir=}";;
	--install-dir=*) installdir="${arg#--install-dir=}";;
	--download-only) download_only="yes";;
	--float) use_float="yes";;
	--cpu) use_arch="cpu";;
	--jit|--cuda) use_arch="cuda";;
	--hip) use_arch="hip";;
	--qdpjit=no) use_qdpjit="nop";;
	--qdpjit=yes) use_qdpjit="yes";;
	--restructure) use_restructure="yes";;
	--superb) use_superb="yes";use_superb_next="nop";;
	--superb-next) use_superb="yes";use_superb_next="yes";;
	--avx) use_march="avx";;
	--avx2) use_march="avx2";;
	--avx512) use_march="avx512";;
	--knl) use_march="knl";;
	--zen2) use_march="zen2";;
	--zen3) use_march="zen3";;
	--mg) use_mg="yes";;
	--next) use_next="yes";use_superb="yes";use_superb_next="yes"; use_pdf_next="yes";;
	--pdf) use_pdf="yes";;
	--meta) use_next="yes";use_superb="yes";use_superb_next="yes"; use_pdf_next="yes"; use_meta="yes";;
	--clean) action="clean";do_cleaning="yes";;
	--install) action="install";;
	--update) action="update";;
	--llvm=build) use_llvm="llvm";;
	--llvm=system) use_llvm="llvm-system";;
	--thrust=build) use_thrust="thrust";;
	--thrust=system) use_thrust="thrust-system";;
	--cmake=build) use_cmake="cmake";;
	--cmake=system) use_cmake="cmake-system";;
	--blas=openblas) use_blas="openblas";;
	--blas=openblas-system) use_blas="openblas-system";;
	--blas=atlas-system) use_blas="atlas-system";;
	--blas=mkl) use_blas="mkl-system";;
	--openmp=no) use_openmp="nop";;
	--openmp=yes) use_openmp="yes";;
	--mpi=no) use_mpi="nop";;
	--mpi=yes) use_mpi="yes";;
	--gmp=build) use_gmp="gmp";;
	gmp) gmp="$action"; use_gmp="gmp";;
	--gmp=system) use_gmp="gmp-system";;
	--libxml2=build) use_libxml2="libxml2";;
	--libxml2=system) use_libxml2="libxml2-system";;
	--automake=build|automake) automake="$action";;
	--automake=system) ;;
	--tinfo=build) use_tinfo="tinfo";;
	--tinfo=system) use_tinfo="tinfo-system"; ncurses="$action";;
	--autoflags=no) use_autoflags="nop";;
	--autoflags=yes) use_autoflags="yes";;
	-g) use_opt="debug";;
	-O) use_opt="opt";;
	-Onone) use_opt="nop";;
	--std=c++11) use_std="c++11";;
	--std=c++14) use_std="c++14";;
	--std=c++17) use_std="c++17";;
	--std=c++20) use_std="c++20";;
	--std=c++23) use_std="c++23";;
	--env=*) do_export_env="${arg#--env=}";;
	openblas) openblas="$action";use_blas="openblas";;
	openblas-gcc) openblas="$action";use_blas="openblas";openblas_use_gcc="yes";;
	cmake) cmake="$action";use_cmake="cmake";;
	llvm) llvm="$action";use_llvm="llvm";;
	cub) cub="$action";;
	boost) boost="$action";;
	ncurses) ncurses="$action";;
	thrust) thrust="$action";use_thrust="thrust";;
	qmp) qmp="$action";;
	qdp) qdp="$action";;
	superbblas) superbblas="$action";;
	qphix) qphix="$action";;
	primme) primme="$action";;
	magma) magma="$action";;
	mgproto) mgproto="$action";;
	quda) quda="$action";;
	mugiq) mugiq="$action";;
	chroma) chroma="$action";;
	laplace_eigs) laplace_eigs="$action";;
	adat) adat="$action";;
	colorvec) colorvec="$action";;
	tensor) tensor="$action";;
	hadron) hadron="$action";;
	harom) harom="$action";;
	redstar) redstar="$action";;
	libxml2) libxml2="$action";use_libxml2="libxml2";;
	libfuse3) libfuse3="$action";use_libfuse3="libfuse3";;
	anarchofs) anarchofs="$action";;
	hdf5) hdf5="$action";;
	gsl) gsl="$action";;
	analysis) analysis="$action"; use_pdf="yes";;
	gcc) gcc="$action";;
	openmpi) openmpi="$action";;
	mvapich2) mvapich2="$action";;
	cpm) cpm="$action";;
	*=*) export ${arg%%=*}="${arg#*=}";;
	--help|-h) echo "$hlp_msg"; exit 0;;
	*) echo "Sorry! Unsupported option '$arg'"; echo "$hlp_msg"; exit 1;;
	esac
	shift
done

# Prompting

last_status=0 # Last command status
run() {
	echo "$> CFLAGS='$CFLAGS' \\"
	echo "   CXXFLAGS='$CXXFLAGS' \\"
	echo "   LDFLAGS='$LDFLAGS' \\"
	echo "   $@"
	"$@" < /dev/null
	last_status=$?
	if [ $last_status -ne 0 ]; then
		echo "$> last command failed with exit status $last_status"
		exit $last_status
	fi
	return 0
}

run_light() {
	echo "$> $@"
	"$@" < /dev/null
	last_status=$?
	if [ $last_status -ne 0 ]; then
		echo "$> warning: last command failed with exit status $last_status"
	fi
	return $last_status
}

info() {
	echo "#>" "$@"
}

check_success() {
	echo "Exit status $last_status"
	[ $last_status -ne 0 ] && exit $last_status
}

# Set the default for use_mpi
if [ ${use_mpi} == duno ] ; then
	if [ x${openmpi} != x -o x${mvapich2} ] || [ x${adat} == x -a x${colorvec} == x -a x${redstar} == x ] ; then
		use_mpi="yes"
	else
		use_mpi="nop"
	fi
fi

# Set default compilers
if [ x${openmpi}x == xx -a x${mvapich2}x == xx ]; then
	if [ $use_mpi == yes ] ; then
		CC="${CC:-mpicc}"
		CXX="${CXX:-mpicxx}"
	fi
else
	if [ x${CXX} == xmpicxx -o x${CC} == xmpicc ]; then
		echo "When compiling openmpi or mvapich2, please set \$CC and \$CXX to something else other than mpicc and mpicxx"
		exit 1
	fi
fi

# Set the default for the use of qdp-jit

if [ x$use_qdpjit == x ] ; then
	use_qdpjit=nop
	[ $use_arch != cpu ] && use_qdpjit=yes
fi

# Add extra flags

if [ x${use_std}x == xx ]; then
	use_std="c++14"
	# qdp-jit needs c++20
	[ $use_arch != cpu -a $use_qdpjit == yes ] && use_std="c++20"
	# adat, colorvec, redstar needs c++20
	[  x${adat} != x -o x${colorvec} != x -o x${redstar} != x ] && use_std="c++20"
fi

detect_compiler() {
	compiler="any"
	if [ x${gcc}x != xx ]; then
		compiler="gcc"
	elif ( $CXX --version 2>&1 | grep -q '^g++' ); then
		compiler="gcc"
	elif ( $CXX --version 2>&1 | grep -q 'clang version' ); then
		compiler="clang"
	elif ( $CXX --version 2>&1 | grep -q '^nvc' ); then
		compiler="nvc"
	elif ( $CXX -v 2>&1 | grep -q 'oneAPI DPC' ); then
		compiler="icx"
	elif ( $CXX -v 2>&1 | grep -q 'ICC' ); then
		compiler="icc"
	elif ( $CXX -v 2>&1 | grep -q 'icpc' ); then
		compiler="icc"
	elif ( $CXX -v 2>&1 | grep -q 'oneAPI' ); then
		compiler="icx"
	fi
	echo $compiler
}

detect_fortran_compiler() {
	compiler="any"
	if [ x${gcc}x != xx -o x${FC}x == xx ]; then
		compiler="gcc"
	elif ( $FC --version 2>&1 | grep -q '^GNU Fortran' ); then
		compiler="gcc"
	elif ( $FC --version 2>&1 | grep -q '^nvfortran' ); then
		compiler="nvc"
	elif ( $FC --version 2>&1 | grep -q 'flang[^ ]* version' ); then
		compiler="flang"
	elif ( $FC --version 2>&1 | grep -q 'IFX' ); then
		compiler="icx"
	elif ( $FC --version 2>&1 | grep -q 'ifx' ); then
		compiler="icx"
	elif ( $FC --version 2>&1 | grep -q 'oneAPI' ); then
		compiler="icx"
	fi
	echo $compiler
}

# If the user gives BLAS options LDFLAGS or LIBS, use them.
# Otherwise, try to detect an available BLAS on the system,
# or compile OpenBLAS

if [ x${use_blas}x == xx ]; then
	info "No BLAS suggestion give; detecting BLAS..."
	case "$LDFLAGS $LIBS" in
	*libmkl*|*-mkl*) use_blas="mkl-system";;
	*openblas*) use_blas="openblas-system";;
	*atlas*) use_blas="atlas-system";;
	*)
		if [ x${openblas}x != xx ]; then
			use_blas="openblas"
		elif [ x${MKLROOT}x != xx ]; then
			use_blas="mkl-system"
			CFLAGS+=" -I${MKLROOT}/include"
			CXXFLAGS+=" -I${MKLROOT}/include"
			LIBS+=" -L${MKLROOT}/lib/intel64 -Wl,--no-as-needed -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -liomp5 -lpthread -lm -ldl"
		elif pkg-config --cflags openblas &> /dev/null; then
			use_blas="openblas-system"
			CFLAGS+=" `pkg-config --cflags openblas`"
			CXXFLAGS+=" `pkg-config --cflags openblas`"
			LIBS+=" `pkg-config --libs --static openblas`"
		elif pkg-config --cflags atlas &> /dev/null; then
			use_blas="atlas-system"
			CFLAGS+=" `pkg-config --cflags atlas`"
			CXXFLAGS+=" `pkg-config --cflags atlas`"
			LIBS+=" `pkg-config --libs atlas`"
		else
			use_blas="openblas"
		fi
	;;
	esac
fi

# Detect GMP

if [ x${use_gmp}x == xx ]; then
	info "No GMP suggestion give; detecting GMP..."
	case "$LDFLAGS $LIBS" in
	*gmp*) use_gmp="gmp-system";;
	*)
		if [ x${gmp}x != xx ]; then
			use_gmp="gmp"
		elif pkg-config --libs gmpxx &> /dev/null || [ -f /usr/include/gmpxx.h ]; then
			use_gmp="gmp-system"
		else
			use_gmp="gmp"
		fi
		;;
	esac
fi
if [ ${use_gmp} == "gmp-system" ]; then
	case "$LDFLAGS $LIBS" in
	*gmp*)
		# Do nothing
		;;
	*)
		if pkg-config --libs gmpxx &> /dev/null ; then
			LIBS+=" `pkg-config --libs gmpxx`"
			CFLAGS+=" `pkg-config --cflags gmpxx`"
			CXXFLAGS+=" `pkg-config --cflags gmpxx`"
	        else
			# Wild guessing
			LIBS+=" -lgmpxx -lgmp"
		fi
		;;
	esac
fi

# Detect libxml2

if [ x${use_libxml2}x == xx ]; then
	info "No libxml2 suggestion give; detecting libxml2..."
	case "$LDFLAGS $LIBS" in
	*xml2*) use_libxml2="libxml2-system";;
	*)
		if [ x${libxml2}x != xx ]; then
			use_libxml2="libxml2"
		elif pkg-config --libs libxml-2.0 &> /dev/null ; then
			use_libxml2="libxml2-system"
		else
			use_libxml2="libxml2"
		fi
		;;
	esac
fi
if [ ${use_libxml2} == "libxml2-system" ]; then
	case "$LDFLAGS $LIBS" in
	*xml2*)
		# Do nothing
		;;
	*)
		if pkg-config --libs libxml-2.0 &> /dev/null ; then
			CFLAGS+=" `pkg-config --cflags libxml-2.0`"
			CXXFLAGS+=" `pkg-config --cflags libxml-2.0`"
			LIBS+=" `pkg-config --libs libxml-2.0`"
		else
			# Wild guessing
			CFLAGS+=" -I/usr/include/libxml2"
			CXXFLAGS+=" -I/usr/include/libxml2"
			LIBS+=" -lxml2"
		fi
		;;
	esac
fi

# Detect tinfo

if [ x${use_tinfo}x == xx ]; then
	info "No tinfo suggestion give; detecting tinfo..."
	case "$LDFLAGS $LIBS" in
	*tinfo*) use_tinfo="tinfo-system";;
	*)
		if [ x${ncurses}x != xx ]; then
			use_tinfo="tinfo"
		elif pkg-config --libs tinfo &> /dev/null ; then
			use_tinfo="tinfo-system"
		else
			use_tinfo="tinfo"
		fi
		;;
	esac
fi

# Detect libfuse3

if [ x${use_libfuse3}x == xx ]; then
	info "No libfuse3 suggestion give; detecting libfuse3..."
	case "$LDFLAGS $LIBS" in
	*fuse3*) use_libfuse3="libfuse3-system";;
	*)
		if pkg-config --libs fuse3 &> /dev/null ; then
			use_libfuse3="libfuse3-system"
		else
			use_libfuse3="libfuse3"
		fi
		;;
	esac
fi

# Detect if there is a cmake available in case the user does not give a clue

if [ x${use_cmake}x == xx ]; then
	info "No cmake suggestion given; detecting cmake version..."
	use_cmake="cmake"
	if cmake --version &> /dev/null ; then
		cmake_version="`cmake --version 2>&1  | grep "^cmake version" | tr . ' '`"
		ver_maj="`echo $cmake_version | while read a a ver_maj ver_minor a ; do echo $ver_maj; done`"
		ver_minor="`echo $cmake_version | while read a a ver_maj ver_minor a ; do echo $ver_minor; done`"
		( [ $use_arch != hip -a $ver_maj -ge 3 -a $ver_minor -ge 18 ] || [ $use_arch == hip -a $ver_maj -ge 3 -a $ver_minor -ge 21 ] ) && use_cmake="cmake-system"
	fi
fi

# Add hipconfig -l into the PATH

if [ $use_arch == hip ]; then
	[ x${HIPCONFIG}x == xx ] && HIPCONFIG="$( which hipconfig )"
	export PATH="$PATH:`$HIPCONFIG -l`"
fi

# Detect if there is a LLVM available in case the user does not give a clue
# NOTE: compile the mainstream llvm for llvm 17+ when using qdpjit

if [ x${use_llvm}x == xx ]; then
    if [ x${llvm}x != xx -o $use_arch != hip ]; then
        use_llvm="llvm"
    else
	llvm_ver="$( `hipconfig -R`/llvm/bin/llvm-config --version )"
        case $llvm_ver in
	14*|15*|16*)         use_llvm="llvm-system" ;;
        *)                   use_llvm="llvm";;
        esac
    fi
fi

# Make sure that the LLVM on path in the one from rocm when using HIP

if [ ${use_arch} == hip -a $use_llvm == llvm-system ] ; then
	if [ `which llvm-config` != `hipconfig -R`/llvm/bin/llvm-config ] ; then
		export PATH="`hipconfig -R`/llvm/bin:$PATH"
		export LD_LIBRARY_PATH="`hipconfig -R`/llvm/lib:$LD_LIBRARY_PATH"
	fi
fi

# Detect if there is thrust available in case the user does not give a clue.
# The first good version is provided with CUDA 12 and HIP 5.4

if [ x${use_thrust}x == xx ]; then
	if [ x${thrust}x != xx ]; then
		use_thrust="thrust"
	elif [ $use_arch == hip ]; then
        	rocm_ver="`hipconfig --version`"
        	case $rocm_ver in
		4.*|5.0*|5.1*|5.2*|5.3*) use_thrust="thrust" ;;
		*) use_thrust="thrust-system" ;;
        	esac
	elif [ $use_arch == cuda ]; then
		cuda_version="`nvcc -V | sed -n 's/^.*release \([^.]\+\).*$/\1/p'`"
		if [ $cuda_version -lt 12 ]; then
			use_thrust="thrust"
		else
			use_thrust="thrust-system"
		fi
	else
		use_thrust="thrust"
	fi
fi

# MAGMA and other packages have problems to find cuda libraries when using NVHPC; so we help them
if [ x${CUDADIR_extra}x != xx ]; then
	CMAKE_EXTRA_FLAGS+="
		-DCUDA_cublas_LIBRARY=${CUDADIR_extra}/lib64/libcublas.so
		-DCUDA_cublas_device_LIBRARY=${CUDADIR_extra}/lib64/libcublasLt.so
		-DCUDA_cusolver_LIBRARY=${CUDADIR_extra}/lib64/libcusolver.so
		-DCUDA_cusparse_LIBRARY=${CUDADIR_extra}/lib64/libcusparse.so
		-DCUDA_nppi_LIBRARY=${CUDADIR_extra}/lib/lib64/libnppial.so"
	CFLAGS+=" -I${CUDADIR_extra}/include" 
	CXXFLAGS+=" -I${CUDADIR_extra}/include"
	LDFLAGS+=" -L${CUDADIR_extra}/lib64"
fi

# Process dependencies

if [ $use_arch == cpu ]; then
	[ $use_mg == yes -a x${chroma}x != xx ] && mgproto="${mgproto:-update}"
	[ x${mgproto}x != xx ] && qphix="${qphix:-update}"
	[ x${mgproto}x != xx ] && primme="${primme:-update}"
else
	[ $use_mg == yes -a x${chroma}x != xx ] && quda="${quda:-update}"
	#[ $use_mg == yes -a $use_next == yes ] && mugiq="${mugiq:-update}"
fi
[ x${quda}x != xx ] && cpm="${cpm:-update}"
[ x${mugiq}x != xx ] && quda="${quda:-update}"
[ x${chroma}x != xx -a $use_superb == yes ] && superbblas="${superbblas:-update}"
[ x${chroma}x != xx -a $use_next == yes ] && boost="${boost:-update}"
[ x${chroma}x != xx -a x${superbblas}x != xx ] && primme="${primme:-update}"
[ x${mgproto}x != xx ] && primme="${primme:-update}"
[ x${qphix}${mgproto}${quda}${chroma}${laplace_eigs}x != xx ] && qdp="${qdp:-update}"
[ x${qphix}${quda}${analysis}x != xx ] && eigen="${eigen:-update}"

[ x${analysis}x != xx ] && redstar="${redstar:-update}" && hdf5="${hdf5:-update}" && gsl="${gsl:-update}"
[ x${laplace_eigs}x != xx ] && primme="${primme:-update}"
[ x${redstar}x != xx ] && hadron="${hadron:-update}" && adat="${adat:-update}" && colorvec="${colorvec:-update}"
[ x${colorvec}x != xx ] && hadron="${hadron:-update}" && adat="${adat:-update}"
[ x${adat}x != xx -a ${use_gmp} == gmp ] && gmp="${gmp:-update}"
[ x${gcc}x != xx ] && gmp="${gmp:-update}"
[ x${adat}x != xx -a ${use_superb} == yes ] && superbblas="${superbblas:-update}"
[ x${harom}x != xx ] && hadron="${hadron:-update}" && qdp="${qdp:-update}"
[ x${hadron}x != xx ] && tensor="${tensor:-update}"
[ x${qdp}x != xx ] && qmp="${qmp:-update}"


[ $use_arch != cpu -a x${qdp}x != xx -a ${use_qdpjit} == yes -a $use_llvm == llvm ] && llvm="${llvm:-update}" && lld="${lld:-update}" && unwind="${unwind:-update}"
[ x${tensor}${primme}${superbblas}${mgproto}${chroma}x != xx -a $use_blas == openblas ] && openblas="${openblas:-update}"
[ x${superbblas}x != xx -a $use_blas == openblas ] && openblas="${openblas:-update}"
[ x${superbblas}x != xx -a $use_superb_next == yes ] && xsimd="${xsimd:-update}"
[ x${superbblas}x != xx -a ${use_mpi} == yes ] && anarchofs="${anarchofs:-update}"
if [ $use_blas != openblas -a x${openblas}x != xx ]; then
	echo "Incompatible options: --blas!=openblas but also asking for compiling openblas"
	exit 1
fi
if [ $use_arch != cpu -a x${laplace_eigs}${harom}x != xx ]; then
	echo "Incompatible options: --cuda or --hip cannot be use while targeting laplace_eigs or harom"
	exit 1
fi
[ $use_arch != cpu -a x${superbblas}${quda}x != xx -a $use_thrust == thrust ] && thrust="${thrust:-update}"
[ x${thrust}x != xx -a $use_arch == cuda ] && cub="${cub:-update}"
[ x${thrust}x != xx -a $use_arch == hip ] && prim="${prim:-update}"
if [ $use_thrust != thrust -a x${thrust}x != xx ]; then
	echo "Incompatible options: --thrust=system but also asking for compiling thrust"
	exit 1
fi
[ x${qdp}x != xx -a $use_libxml2 == libxml2 ] && libxml2="${libxml2:-update}"
[ x${adat}x != xx -a $use_libxml2 == libxml2 ] && libxml2="${libxml2:-update}"
if [ $use_libxml2 != libxml2 -a x${libxml2}x != xx ]; then
	echo "Incompatible options: --libxml2=system but also asking for compiling libxml2"
	exit 1
fi

if [ $use_superb_next == yes -a $use_restructure == yes ] ; then
	echo "Incompatible options: --superb-next and --restructure"
	exit 1
fi

if [ $use_mpi != yes -a x${qmp}${quda}${anarchofs} != x ] ; then
	echo "Incompatible options: --mpi=no and installing qmp, quda or anarchofs"
	exit 1
fi

[ x${qdp}x != xx -a $use_arch != cpu -a $use_tinfo == tinfo ] && ncurses="${ncurses:-update}"

[ x${llvm}${qphix}${mgproto}${quda}${mugiq}${magma}x != xx -a $use_cmake == cmake ] && cmake="${cmake:-update}"

[ x${gcc}x != xx -a x${mpfr}x == xx ] && mpfr="${mpfr:-update}"
[ x${gcc}x != xx -a x${isl}x == xx ] && isl="${isl:-update}"
[ x${gcc}x != xx -a x${mpc}x == xx ] && mpc="${mpc:-update}"
[ x${openmpi}x != xx -a x${ucx}x == xx ] && ucx="${ucx:-update}"

# Detecting flags

if [ ${use_autoflags} == yes ]; then
	info "No CPU architecture given; guessing ..."
	if [ x${use_march}x == xx ]; then
		if grep -q "AMD EPYC ...4" /proc/cpuinfo ; then
			info "Detected AMD zen4"
			use_march="zen4"
		elif grep -q "AMD EPYC ...3" /proc/cpuinfo ; then
			info "Detected AMD zen3"
			use_march="zen3"
		elif grep -q "vendor_id.*AuthenticAMD" /proc/cpuinfo ; then
			info "Detected AMD zen2"
			use_march="zen2"
		elif grep -q "cpu.*:.*POWER" /proc/cpuinfo ; then
			info "Detected POWER architecture"
			use_march="power"
		elif grep -q "vendor_id.*GenuineIntel" /proc/cpuinfo ; then
			if grep -q "amx_bf16" /proc/cpuinfo ; then
				info "Detected intel with avx512_fp16 support"
				use_march="avx512_fp16"
			elif grep -q "avx512" /proc/cpuinfo ; then
				info "Detected intel with avx512 support"
				use_march="avx512"
			elif grep -q "avx2" /proc/cpuinfo ; then
				info "Detected intel with avx2 support"
				use_march="avx2"
			else
				info "Detected intel with avx support"
				use_march="avx"
			fi
		fi
	fi
	info "Detecting compiler...`detect_compiler`"
	case "${use_march}" in
		knl)
			# Active special tricks for a special architecture
			case "`detect_compiler`" in
			icc)
				CXXFLAGS+=" -xCORE-AVX2 -axCORE-AVX512,MIC-AVX512"
				CFLAGS+=" -xCORE-AVX2 -axCORE-AVX512,MIC-AVX512"
				;;
			*)
				CXXFLAGS+=" -march=knl -mavx512f -mavx512pf -mavx512er -mavx512cd"
				CFLAGS+=" -march=knl -mavx512f -mavx512pf -mavx512er -mavx512cd"
				;;
			esac
			;;
		avx512_fp16)
			case "`detect_compiler`" in
			icc)
				CXXFLAGS+=" -xCORE-AVX512"
				CFLAGS+=" -xCORE-AVX512"
				;;
			*)
				CXXFLAGS+=" -march=sapphirerapids"
				CFLAGS+=" -march=sapphirerapids"
				;;
			esac
			;;
		avx512)
			case "`detect_compiler`" in
			icc)
				CXXFLAGS+=" -xCORE-AVX512"
				CFLAGS+=" -xCORE-AVX512"
				;;
			*)
				CXXFLAGS+=" -march=skylake-avx512"
				CFLAGS+=" -march=skylake-avx512"
				;;
			esac
			;;
		avx2)
			case "`detect_compiler`" in
			icc)
				CXXFLAGS+=" -xCORE-AVX2"
				CFLAGS+=" -xCORE-AVX2"
				;;
			*)
				CXXFLAGS+=" -march=haswell -mavx2"
				CFLAGS+=" -march=haswell -mavx2"
				;;
			esac
			;;
		avx)
			case "`detect_compiler`" in
			icc)
				CXXFLAGS+=" -xCORE-AVX"
				CFLAGS+=" -xCORE-AVX"
				;;
			*)
				CXXFLAGS+=" -march=ivybridge -mavx"
				CFLAGS+=" -march=ivybridge -mavx"
				;;
			esac
			;;
		zen2)
			case "`detect_compiler`" in
			*)
				CXXFLAGS+=" -march=znver2"
				CFLAGS+=" -march=znver2"
				;;
			esac
			;;
		zen3)
			case "`detect_compiler`" in
			*)
				CXXFLAGS+=" -march=znver3"
				CFLAGS+=" -march=znver3"
				;;
			esac
			;;
		zen4)
			case "`detect_compiler`" in
			*)
				CXXFLAGS+=" -march=znver4"
				CFLAGS+=" -march=znver4"
				;;
			esac
			;;
		power)
			info "Not setting specific architecture flags for POWER architecture"
			;;
	esac

	if [ x${use_openmp}x == xx ] && [ "`uname -s`" == "Darwin" ] && [ "`detect_compiler`" == clang ] && ( $CXX --version 2>&1 | grep -q "Apple clang" ); then
		apple_found_omp="nop"
		if command -v pkg-config &> /dev/null && pkg-config --exists libomp; then
			libomp_apple_cflags="`pkg-config --cflags libomp`"
			libomp_apple_libs="`pkg-config --libs libomp`"
			apple_found_omp="yes"
		else
			for prefix in /opt/homebrew/opt/libomp /usr/local/opt/libomp ; do
				if [ -d "$prefix" ]; then
					libomp_apple_cflags="-I${prefix}/include"
					libomp_apple_libs="-L${prefix}/lib -lomp"
					apple_found_omp="yes"
					break
				fi
			done
		fi
		if [ $apple_found_omp == yes ] ; then
			CXXFLAGS+=" -Xpreprocessor -fopenmp ${libomp_apple_cflags}"
			CFLAGS+=" -Xpreprocessor -fopenmp ${libomp_apple_cflags}"
			LDFLAGS+=" ${libomp_apple_libs}"
			LIBS+=" ${libomp_apple_libs}"
			info "Found libomp for Apple clang; enabling OpenMP"
			use_openmp="yes"
		else
			info "Apple clang on macOS lacks OpenMP by default; disabling OpenMP unless explicitly requested"
			use_openmp="nop"
		fi
	fi
	[ x${use_openmp} == x ] && use_openmp="yes"

	if ! ( echo ${CXXFLAGS} | grep -q openmp ) && [ ${use_openmp} == yes ]; then
		# QDP is compiled with OpenMP, so we need to add the flag
		case "`detect_compiler`" in
		icc|icx)
			CXXFLAGS+=" -qopenmp"
			CFLAGS+=" -qopenmp"
			LDFLAGS+=" -qopenmp"
			;;
		*)
			echo detecting craype
			which "$CC" | grep craype 
			# Cray compiler wrapper incorrectly add extra flags when adding -fopenmp
			if [ $use_arch == hip ] && which "$CC" | grep craype &>/dev/null ; then
				CXXFLAGS+=" --craype-append-opt=-fopenmp"
				CFLAGS+=" --craype-append-opt=-fopenmp"
				LDFLAGS+=" --craype-append-opt=-fopenmp"
			else
				CXXFLAGS+=" -fopenmp"
				CFLAGS+=" -fopenmp"
				LDFLAGS+=" -fopenmp"
			fi
			;;
		esac
	fi
	case ${use_opt} in
	debug)
		CFLAGS+=" -g3 -O0"
		CXXFLAGS+=" -g3 -O0"
		LDFLAGS+=" -g3 -O0"
		CMAKE_EXTRA_FLAGS+=" -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=OFF"
		;;
	opt)
		CFLAGS+=" -O3"
		CXXFLAGS+=" -O3"
		LDFLAGS+=" -O3"
		;;
	esac
	case "$CXXFLAGS" in
	*-std=*) ;;
	*) CXXFLAGS+=" -std=$use_std" ;;
	esac
	# Old versions of icc need this
	case "$CFLAGS" in
		*-std=*) ;;
		*) 
			if [ "`uname -s`" == "Darwin" ]; then
				CFLAGS+=" -std=c11 -D_DARWIN_C_SOURCE"
			else
				CFLAGS+=" -std=c11 -D_XOPEN_SOURCE=500"
			fi
			;;
	esac
elif [ x${use_march}x = xx ] ; then
	info "No architecture information given, just assuming AVX"
	use_march="avx"
	[ x${use_openmp} == x ] && use_openmp="yes"
fi

if [ ${use_arch} == hip ]; then
	export AR="${AR:-llvm-ar}"
	export AS="${AS:-llvm-as}"
	export LD="${LD:-ld.lld}"
	export RANLIB="${RANLIB:-llvm-ranlib}"
fi

# Print basic variables

info "Using PATH: $PATH"
info "Using LD_LIBRARY_PATH: $LD_LIBRARY_PATH"
info "Using CUDADIR: $CUDADIR"
info "Using CUDADIR_extra: $CUDADIR_extra"
info "Using cmake: ${use_cmake}"
info "Using llvm: ${use_llvm}"
info "Using thrust: ${use_thrust}"
info "Using BLAS: ${use_blas}"
info "Using GMP: ${use_gmp}"
info "Using libxml2: ${use_libxml2}"
info "Using CC=$CC"
info "Using CFLAGS=$CFLAGS"
info "Using CXX=$CXX"
info "Using CXXFLAGS=$CXXFLAGS"
info "Using FC=$FC"
info "Using LDFLAGS=$LDFLAGS"
info "Using LIBS=$LIBS"
export CC CFLAGS CXX CXXFLAGS FC LDFLAGS LIBS


# Download

mkdir -p $srcdir
srcdir="`realpath $srcdir`"
info "Source directory: $srcdir"

if [ x${qmp}x != xx ]; then
	qmp_src="qmp"
fi
if [ x${qdp}x != xx ]; then
	qdp_src="qdpxx"
	if [ $use_arch != cpu -a $use_qdpjit == yes ] ; then
	       	llvm_ver="`llvm-config --version`"
        	case $llvm_ver in
		14*|15*|16*) qdp_src="qdp-jit-prev-llvm17" ;;
		*)           qdp_src="qdp-jit" ;;
        	esac
	fi
fi
if [ x${quda}x != xx ]; then
	quda_src="quda"
	cpm_src="cpm"
	#[ $use_next == yes ] && quda_src="quda-mugiq"
fi
if [ x${mugiq}x != xx ]; then
	mugiq_src="mugiq"
fi
if [ x${qphix}x != xx ]; then
	qphix_src="qphix"
fi
if [ x${mgproto}x != xx ]; then
	mgproto_src="mgproto"
fi
if [ x${chroma}x != xx ]; then
	chroma_src="chroma"
	if [ $use_next == yes ]; then
		chroma_src="chroma-fs-sp"
	elif [ $use_restructure == yes ]; then
		chroma_src="chroma-restructure"
	elif [ $use_superb_next == yes ]; then
		chroma_src="chroma-sp"
	fi
fi
if [ x${primme}x != xx ]; then
	primme_src="primme"
fi
if [ x${magma}x != xx ]; then
	magma_src="magma"
fi
if [ x${cmake}x != xx ]; then
	cmake_src="cmake"
fi
if [ x${llvm}x != xx ]; then
	llvm_src="llvm"
fi
if [ x${cub}x != xx ]; then
	cub_src="cub"
fi
if [ x${prim}x != xx ]; then
	prim_src="rocPRIM"
fi
if [ x${thrust}x != xx ]; then
	[ $use_arch == cuda ] && thrust_src="thrust"
	[ $use_arch == hip ] && thrust_src="rocThrust"
fi
if [ x${openblas}x != xx ]; then
	openblas_src="openblas"
fi
if [ x${eigen}x != xx ]; then
	eigen_src="eigen"
fi
if [ x${superbblas}x != xx ]; then
	superbblas_src="superbblas"
	[ $use_superb_next == yes ] && superbblas_src="superbblas-sp"
fi
if [ x${adat}x != xx ]; then
	adat_src="adat"
	[ $use_pdf == yes ] && adat_src="adat-pdf"
	[ $use_pdf_next == yes ] && adat_src="adat-pdf-next"
	[ $use_meta == yes ] && adat_src="adat-pdf-next-meta"
fi
if [ x${colorvec}x != xx ]; then
	colorvec_src="colorvec"
	[ $use_pdf == yes ] && colorvec_src="colorvec-pdf"
	[ $use_pdf_next == yes ] && colorvec_src="colorvec-pdf-next"
	[ $use_meta == yes ] && colorvec_src="colorvec-pdf-next-meta"
fi
if [ x${tensor}x != xx ]; then
	tensor_src="tensor"
fi
if [ x${hadron}x != xx ]; then
	hadron_src="hadron"
	[ $use_meta == yes ] && hadron_src="hadron-meta"
fi
if [ x${harom}x != xx ]; then
	harom_src="harom"
fi
if [ x${redstar}x != xx ]; then
	redstar_src="redstar"
	[ $use_pdf == yes ] && redstar_src="redstar-pdf"
	[ $use_pdf_next == yes ] && redstar_src="redstar-pdf-next"
	[ $use_meta == yes ] && redstar_src="redstar-pdf-next-meta"
fi
if [ x${laplace_eigs}x != xx ]; then
	laplace_eigs_src="laplace_eigs"
fi
if [ x${gmp}x != xx ]; then
	gmp_src="gmp"
fi
if [ x${libxml2}x != xx ]; then
	libxml2_src="libxml2"
fi
if [ x${automake}x != xx ]; then
	automake_src="automake"
fi
if [ x${xsimd}x != xx ]; then
	xsimd_src="xsimd"
fi
if [ x${boost}x != xx ]; then
	boost_src="boost"
fi
if [ x${ncurses}x != xx ]; then
	ncurses_src="ncurses"
fi
if [ x${anarchofs}x != xx ]; then
	anarchofs_src="anarchofs"
fi
if [ x${analysis}x != xx ]; then
	analysis_src="analysis"
fi
if [ x${hdf5}x != xx ]; then
	hdf5_src="hdf5"
fi
if [ x${gsl}x != xx ]; then
	gsl_src="gsl"
fi
if [ x${libfuse3}x != xx ]; then
	libfuse3_src="libfuse3"
fi
if [ x${gcc}x != xx ]; then
	gcc_src="gcc"
	mpfr_src="mpfr"
	isl_src="isl"
	mpc_src="mpc"
fi
if [ x${openmpi}x != xx ]; then
	openmpi_src="openmpi"
fi
if [ x${ucx}x != xx ]; then
	ucx_src="ucx"
fi
if [ x${mvapich2}x != xx ]; then
	mvapich2_src="mvapich2"
fi



cat << EOF | while read act proj
$cmake        $cmake_src
$llvm         $llvm_src
$lld          $lld_src
$unwind       $unwind_src
$cub          $cub_src
$prim         $prim_src
$thrust       $thrust_src
$openblas     $openblas_src
$eigen        $eigen_src
$primme       $primme_src
$magma        $magma_src
$qmp          $qmp_src
$qdp          $qdp_src
$qphix        $qphix_src
$mgproto      $mgproto_src
$superbblas   $superbblas_src
$mugiq        $mugiq_src
$quda         $quda_src
$cpm          $cpm_src
$chroma       $chroma_src
$laplace_eigs $laplace_eigs_src
$adat         $adat_src
$colorvec     $colorvec_src
$tensor       $tensor_src
$hadron       $hadron_src
$harom        $harom_src
$redstar      $redstar_src
$gmp          $gmp_src
$libxml2      $libxml2_src
$xsimd        $xsimd_src
$ncurses      $ncurses_src
$gcc          $gcc_src
$mpfr         $mpfr_src
$isl          $isl_src
$mpc          $mpc_src
$boost        $boost_src
$openmpi      $openmpi_src
$ucx          $ucx_src
$mvapich2     $mvapich2_src
$automake     $automake_src
$anarchofs    $anarchofs_src
$libfuse3     $libfuse3_src
$analysis     $analysis_src
$gsl          $gsl_src
$hdf5         $hdf5_src
EOF
do
        cat << EOF | while read name repo branch
qdpxx                  https://github.com/usqcd-software/qdpxx         devel
qdp-jit                https://github.com/JeffersonLab/qdp-jit         devel
qdp-jit-prev-llvm17    https://github.com/JeffersonLab/qdp-jit         7c0cdf308dba714e544d4b1f0f5dc3d69e1b46df
qmp                    https://github.com/usqcd-software/qmp           devel
chroma                 https://github.com/JeffersonLab/chroma          devel
chroma-sp              https://github.com/JeffersonLab/chroma          eloy/mgproton
chroma-restructure     https://github.com/JeffersonLab/chroma          restructure
chroma-fs-sp           https://github.com/twLQCD/chroma.git            travis/mgproton-progress-blocking-fs
chroma                 https://github.com/JeffersonLab/chroma          devel
qphix                  https://github.com/JeffersonLab/qphix           devel
mgproto                https://github.com/JeffersonLab/mg_proto        devel
mgproto2               https://github.com/twLQCD/mg_proto.git          reuse_prolong
harom                  https://github.com/JeffersonLab/harom           devel
hadron                 https://github.com/JeffersonLab/hadron          devel
hadron-meta            https://github.com/JeffersonLab/hadron          devel-meta
tensor                 https://github.com/JeffersonLab/tensor          master
redstar                https://github.com/JeffersonLab/redstar         devel
redstar-pdf            https://github.com/JeffersonLab/redstar         devel-pdf
redstar-pdf-next       https://github.com/JeffersonLab/redstar         eloy/mix-phasings-with-momclass
redstar-pdf-next-meta  https://github.com/JeffersonLab/redstar         eloy/mix-phasings-with-momclass-with-meta
adat                   https://github.com/JeffersonLab/adat            devel
adat-pdf               https://github.com/JeffersonLab/adat            devel-pdf
adat-pdf-next          https://github.com/JeffersonLab/adat            eloy/mix-phasings-with-momclass
adat-pdf-next-meta     https://github.com/JeffersonLab/adat            eloy/mix-phasings-with-momclass-with-meta
colorvec               https://github.com/JeffersonLab/colorvec        devel
colorvec-pdf           https://github.com/JeffersonLab/colorvec        devel-pdf
colorvec-pdf-next      https://github.com/JeffersonLab/colorvec        eloy/mix-phasings-with-momclass
colorvec-pdf-next-meta https://github.com/JeffersonLab/colorvec        eloy/mix-phasings-with-momclass-with-meta
laplace_eigs           https://github.com/JeffersonLab/laplace_eigs    primme3
primme                 https://github.com/primme/primme                eloy/primme-3.3
magma                  http://icl.utk.edu/projectsfiles/magma/downloads/magma-2.7.1.tar.gz
superbblas             https://github.com/eromero-vlc/superbblas       devel
superbblas-sp          https://github.com/eromero-vlc/superbblas       devel
quda                   https://github.com/lattice/quda                 develop
mugiq                  https://github.com/eromero-vlc/mugiq            master
#mugiq                  https://github.com/ckallidonis/mugiq            master
quda-mugiq             https://github.com/ckallidonis/quda             CK-MGDeflate
eigen                  https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.tar.bz2
cmake                  https://github.com/Kitware/CMake/releases/download/v3.28.3/cmake-3.28.3.tar.gz
llvm                   https://github.com/llvm/llvm-project/releases/download/llvmorg-18.1.8/llvm-project-18.1.8.src.tar.xz
cub                    https://github.com/NVIDIA/cub/archive/refs/tags/1.17.2.tar.gz
thrust                 https://github.com/NVIDIA/thrust/archive/refs/tags/1.17.2.tar.gz
rocThrust              https://github.com/ROCmSoftwarePlatform/rocThrust/archive/refs/tags/rocm-5.4.3.tar.gz
rocPRIM                https://github.com/ROCmSoftwarePlatform/rocPRIM/archive/refs/tags/rocm-5.4.3.tar.gz
openblas               https://github.com/OpenMathLib/OpenBLAS/releases/download/v0.3.28/OpenBLAS-0.3.28.tar.gz
cpm                    https://github.com/cpm-cmake/CPM.cmake/archive/refs/tags/v0.40.2.tar.gz
gmp                    https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz
libxml2                https://download.gnome.org/sources/libxml2/2.10/libxml2-2.10.2.tar.xz
xsimd                  https://github.com/xtensor-stack/xsimd.git	13.0.0
ncurses                https://ftp.gnu.org/gnu/ncurses/ncurses-6.2.tar.gz
mpfr                   https://www.mpfr.org/mpfr-current/mpfr-4.2.1.tar.xz
gcc                    https://mirrors.ocf.berkeley.edu/gnu/gcc/gcc-14.1.0/gcc-14.1.0.tar.xz
isl                    https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.24.tar.bz2
mpc                    https://ftp.gnu.org/gnu/mpc/mpc-1.2.1.tar.gz
boost                  https://boostorg.jfrog.io/artifactory/main/release/1.80.0/source/boost_1_80_0.tar.bz2
ucx                    https://github.com/openucx/ucx/releases/download/v1.16.0/ucx-1.16.0.tar.gz
openmpi                https://download.open-mpi.org/release/open-mpi/v5.0/openmpi-5.0.3.tar.bz2
mvapich2               https://mvapich.cse.ohio-state.edu/download/mvapich/mv2/mvapich2-2.3.7-1.tar.gz
autoconf               http://ftp.gnu.org/gnu/autoconf/autoconf-2.72.tar.xz
automake               https://ftp.gnu.org/gnu/automake/automake-1.16.5.tar.gz
anarchofs              https://github.com/eromero-vlc/anarchofs.git   eloy/daemonless
libfuse3               https://github.com/libfuse/libfuse/releases/download/fuse-3.16.2/fuse-3.16.2.tar.gz
analysis               https://github.com/eromero-vlc/analysis.git eloy/new-makefile
##analysis               https://github.com/CEgerer93/analysis.git master
gsl                    https://ftp.gnu.org/gnu/gsl/gsl-2.8.tar.gz
hdf5                   https://github.com/HDFGroup/hdf5/releases/download/hdf5_1.14.4.3/hdf5.tar.gz
EOF
	do
		[ x${proj}x != x${name}x ] && continue
		[ x${act}x == xupdatex -a -d $srcdir/$proj ] && continue
		if [ $do_cleaning == yes ]; then
			[ x${act}x == xclean -a -d $srcdir/$proj ] && rm -f $srcdir/$proj
			continue
		fi
		info "Downloading $proj"
		run rm -rf $srcdir/$proj $tmp/{d,d.zip,d.bz2,d.xz,d.gz}
		case $repo in
		*zip) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.zip && unzip $tmp/d.zip -d $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*bz2) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.bz2 && tar xjf $tmp/d.bz2 -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*gz) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.gz && tar xzf $tmp/d.gz -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*xz) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.xz && tar xJf $tmp/d.xz -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*git*)
			( GIT_ASKPASS=w git clone --recursive $repo $srcdir/$proj || GIT_ASKPASS=w git clone --recursive ${repo/https:\/\/github.com\//git@github.com:} $srcdir/$proj ) && \
				( cd $srcdir/$proj; git checkout ${branch} && git submodule update --recursive ) || run false # checkout a branch or a commit
			;;
		*) echo "Don't know how to download $repo"; exit 1;;
		esac
	done || exit 1
done || ( echo "Error happened while downloading source codes"  && false ) || exit 1

if [ $download_only == yes ]; then
	if [ $do_cleaning == yes ]; then
		echo "Combining --download-only with --clean actions is meaningless."
		exit 1
	fi
	exit 0
fi

# Installing packages

run mkdir -p $builddir
run mkdir -p $installdir
builddir="`realpath $builddir`"
installdir="`realpath $installdir`"
info "Build directory: $builddir"
info "Install directory: $installdir"
if [ x${do_export_env}x != xx ]; then
	info "Exporting environment in ${do_export_env}"
	rm -f $do_export_env
fi

if [ x${automake}x != xx ]; then
	automake_install="automake"
	sdir="${srcdir}/${automake_src}"
	bdir="${builddir}/${automake_install}"
	idir="${installdir}/${automake_install}"
	info "Doing ${automake} automake; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${automake} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${automake} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		CFLAGS= CXXFLAGS= LDFLAGS= LIBS= run ${sdir}/configure --prefix=${idir} 
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For automake
export PATH="$idir/bin:\$PATH"
EOF
	fi
fi

if [ x${gcc}x != xx ]; then
	gcc_install="gcc"
	sdir="${srcdir}/${gcc_src}"
	bdir="${builddir}/${gcc_install}"
	idir="${installdir}/${gcc_install}"
	info "Doing ${gcc} GCC; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${gcc} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${gcc} == install -o ! -d ${idir} ]; then
		[ -e ${sdir}/mpfr ] || ln -s ${srcdir}/${mpfr_src} ${sdir}/mpfr
		[ -e ${sdir}/isl ] || ln -s ${srcdir}/${isl_src} ${sdir}/isl
		[ -e ${sdir}/mpc ] || ln -s ${srcdir}/${mpc_src} ${sdir}/mpc
		[ -e ${sdir}/gmp ] || ln -s ${srcdir}/${gmp_src} ${sdir}/gmp
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		(
			export CC=gcc
			export CXX=g++
			export CFLAGS=
			export CXXFLAGS=
			export LDFLAGS=
			export LIBS=
			run ${sdir}/configure --prefix=${idir} --disable-bootstrap --disable-multilib --enable-languages="c,c++,fortran" 
			run ${MYMAKE} -j $MAKE_JN
			run ${MYMAKE} install
		)
		popd
	fi
	export PATH=$idir/bin:$PATH
	libexec_gcc=`realpath $idir/libexec/gcc/*/10.1.0`
	libplugin_gcc=`realpath $idir/lib/gcc/*/10.1.0/plugin`
	export LD_LIBRARY_PATH=$idir/lib:$idir/lib64:$libexec_gcc:$LD_LIBRARY_PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For gcc
export LD_LIBRARY_PATH="$idir/lib:$idir/lib64:$libexec_gcc:\$LD_LIBRARY_PATH"
export PATH="$idir/bin:\$PATH"
EOF
	fi
fi


if [ x${ucx}x != xx ]; then
	ucx_install="ucx"
	sdir="${srcdir}/${ucx_src}"
	bdir="${builddir}/${ucx_install}"
	idir="${installdir}/${ucx_install}"
	info "Doing ${ucx} ucx; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${ucx} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${ucx} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		case $use_opt in
		debug) ucx_extra="--enable-debug --enable-logging --enable-assertions --enable-params-check --disable-optimizations" ;;
		opt) ucx_extra="--disable-debug --disable-logging --disable-assertions --disable-params-check --enable-optimizations" ;;
		esac
		case $use_arch in
		cpu) ;;
		cuda) ucx_extra+=" --with-cuda=$CUDADIR" ;;
		hip) ucx_extra+=" --with-rocm=`hipconfig -R`" ;;
		esac
		sed -i 's/-Werror//g' ${sdir}/configure
		CFLAGS= CXXFLAGS= LDFLAGS= LIBS= run ${sdir}/configure --prefix=${idir} --without-java --enable-cma --with-verbs --enable-mt --without-xpmem --disable-doxygen-doc $ucx_extra
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For ucx
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
	fi
fi

if [ x${openmpi}x != xx ]; then
	openmpi_install="openmpi"
	sdir="${srcdir}/${openmpi_src}"
	bdir="${builddir}/${openmpi_install}"
	idir="${installdir}/${openmpi_install}"
	info "Doing ${openmpi} openmpi; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${openmpi} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${openmpi} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		case $use_opt in
		debug) openmpi_extra="--enable-debug" ;;
		opt) openmpi_extra="--disable-debug" ;;
		esac
		case "`detect_compiler`" in
		gcc) openmpi_extra+=" --enable-builtin-atomics" ;;
		esac
		case $use_arch in
		cpu) ;;
		cuda)
			libcuda_path="`find $CUDADIR -name libcuda.so | head -1`"
			inccudart_path="`find $CUDADIR -name cuda_runtime_api.h | head -1`"
			libcudart_path="`find $CUDADIR -name libcudart.so | head -1`"
			openmpi_extra+=" --with-cuda=$CUDADIR --with-cuda-libdir=`dirname $libcuda_path` --enable-mca-dso=btl-smcuda,rcache-rgpusm,rcache-gpusm,accelerator-cuda CPPFLAGS=-I`dirname $inccudart_path` LDFLAGS=-L`dirname $libcudart_path`" ;;
		hip) openmpi_extra+=" --with-rocm=`hipconfig -R`" ;;
		esac
		CFLAGS= CXXFLAGS= LDFLAGS= LIBS= run ${sdir}/configure --prefix=${idir} --with-ucx=${installdir}/${ucx_install} --enable-mca-no-build=btl-uct --disable-oshmem --disable-io-romio $openmpi_extra
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	[ x${CC}x != xx ] && export OMPI_CC=$CC
	[ x${CXX}x != xx ] && export OMPI_CXX=$CXX
	[ x${FC}x != xx ] && export OMPI_FC=$FC
	export CC=mpicc
	export CXX=mpicxx
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For openmpi
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
		[ x${OMPI_CC}x != xx ] && echo export OMPI_CC=$OMPI_CC >> $do_export_env
		[ x${OMPI_CXX}x != xx ] && echo export OMPI_CXX=$OMPI_CXX >> $do_export_env
		[ x${OMPI_FC}x != xx ] && echo export OMPI_FC=$OMPI_FC >> $do_export_env
	fi
fi

if [ x${mvapich2}x != xx ]; then
	mvapich2_install="mvapich2"
	sdir="${srcdir}/${mvapich2_src}"
	bdir="${builddir}/${mvapich2_install}"
	idir="${installdir}/${mvapich2_install}"
	info "Doing ${mvapich2} openmpi; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mvapich2} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mvapich2} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		case $use_arch in
		cpu) mvapich2_extra="" ;;
		cuda)
			mvapich2_extra="--with-cuda=$CUDADIR" ;;
		hip) mvapich2_extra="" ;;
		esac
		CFLAGS= CXXFLAGS= LDFLAGS= LIBS= run ${sdir}/configure --prefix=${idir} --enable-fast=all $mvapich2_extra
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	[ x${CC}x != xx ] && export MPICH_CC=$CC
	[ x${CXX}x != xx ] && export MPICH_CXX=$CXX
	[ x${FC}x != xx ] && export MPICH_FC=$FC
	export CC=mpicc
	export CXX=mpicxx
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For mvapich2
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
		[ x${MPICH_CC}x != xx ] && echo export MPICH_CC=$MPICH_CC >> $do_export_env
		[ x${MPICH_CXX}x != xx ] && echo export MPICH_CXX=$MPICH_CXX >> $do_export_env
		[ x${MPICH_FC}x != xx ] && echo export MPICH_FC=$MPICH_FC >> $do_export_env
	fi
fi


if [ x${cmake}x != xx ]; then
	cmake_install="cmake"
	sdir="${srcdir}/${cmake_src}"
	bdir="${builddir}/${cmake_install}"
	idir="${installdir}/${cmake_install}"
	info "Doing ${cmake} cmake; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${cmake} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${cmake} == install -o ! -d ${idir} ]; then
		for i in 0 1; do
			run rm -rf $bdir $idir
			run mkdir -p $bdir
			pushd $bdir
			if [ $i = 0 ] ; then
			       	if cmake --version &> /dev/null; then
					run_light cmake -DCMAKE_USE_OPENSSL=OFF -DCMAKE_INSTALL_PREFIX=${idir} ${sdir} && \
						run_light ${MYMAKE} -j $MAKE_JN install && popd && break
				else
					run_light $sdir/configure --prefix=$idir && \
						run_light ${MYMAKE} -j $MAKE_JN install && popd && break
				fi
			else
				# On some machines, cmake fails to compile excepting with the system compilers
				(
					export CFLAGS=
					export CXXFLAGS=
					run $sdir/configure --prefix=$idir CC=/usr/bin/gcc CXX=/usr/bin/g++ -- -DCMAKE_USE_OPENSSL=OFF
					run ${MYMAKE} -j $MAKE_JN install
				)
			fi
			popd
		done
	fi
	export PATH=$idir/bin:$PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For cmake
export PATH="$idir/bin:\$PATH"
EOF
	fi
fi

if [ x${ncurses}x != xx ]; then
	ncurses_install="${ncurses_src}"
	sdir="${srcdir}/${ncurses_src}"
	bdir="${builddir}/${ncurses_install}"
	idir="${installdir}/${ncurses_install}"
	info "Doing ${ncurses} ncurses; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${ncurses} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${ncurses} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --disable-shared --enable-static --with-pic
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LD_LIBRARY_PATH+=":${idir}"
	PKG_CONFIG_PATH+=":${idir}/lib/pkgconfig"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For ncurses
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
	fi
fi


if [ x${llvm}x != xx ]; then
	llvm_install="llvm"
	sdir="${srcdir}/${llvm_src}"
	bdir="${builddir}/${llvm_install}"
	idir="${installdir}/${llvm_install}"
	info "Doing ${llvm} LLVM; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${llvm} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${llvm} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		# Decide target
		llvm_targets="X86"
		[ $use_arch == cuda ] && llvm_targets="NVPTX"
		[ $use_arch == hip ] && llvm_targets="AMDGPU"
		pushd $bdir
		LLVM_CC=gcc
		[ $use_arch == hip ] && LLVM_CC=amdclang
		LLVM_CXX=g++
		[ $use_arch == hip ] && LLVM_CXX=amdclang++
		CFLAGS= CXXFLAGS= LIBS= LDFLAGS= run cmake \
		      -DLLVM_ENABLE_TERMINFO="OFF" \
		      -DCMAKE_BUILD_TYPE=Release \
		      -DCMAKE_INSTALL_PREFIX=${idir} \
		      -DLLVM_TARGETS_TO_BUILD="${llvm_targets}" \
		      -DLLVM_ENABLE_ZLIB="OFF" \
		      -DBUILD_SHARED_LIBS="OFF" \
		      -DLLVM_ENABLE_RTTI="OFF"  \
		      -DLLVM_ENABLE_PROJECTS="llvm;lld" \
		      -DLLVM_INCLUDE_BENCHMARKS=OFF \
		      -DLLVM_ENABLE_LIBEDIT=OFF \
		      -DCMAKE_CXX_COMPILER="${LLVM_CXX}" -DCMAKE_C_COMPILER="${LLVM_CC}" \
		      $sdir/llvm
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	export LDFLAGS="-L$idir/lib $LDFLAGS"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For llvm
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
export PATH="$idir/bin:\$PATH"
EOF
	fi
fi

if [ x${cub}x != xx ]; then
	cub_install="cub"
	sdir="${srcdir}/${cub_src}"
	info "Doing ${cub} CUB; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${cub} == clean ] && rm -rf $sdir
	fi
fi

if [ x${prim}x != xx ]; then
	prim_install="prim"
	sdir="${srcdir}/${prim_src}"
	info "Doing ${prim} prim; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${prim} == clean ] && rm -rf $sdir
	fi
fi

if [ x${thrust}x != xx ]; then
	thrust_install="thrust"
	sdir="${srcdir}/${thrust_src}"
	info "Doing ${thrust} thrust; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${thrust} == clean ] && rm -rf $sdir
	fi
fi

if [ x${openblas}x != xx ]; then
	openblas_install="openblas"
	sdir="${srcdir}/${openblas_src}"
	bdir="${builddir}/${openblas_install}"
	idir="${installdir}/${openblas_install}"
	info "Doing ${openblas} OpenBLAS; source=$sdir build=$bdir install=$idir"
	[ "`uname -s`" == "Darwin" -a x${openblas_use_gcc}x == xx ] && openblas_use_gcc="yes"
	openblas_use_openmp=1
	[ x${use_openmp}x == xnopx ] && openblas_use_openmp=0
	if [ $do_cleaning == yes ]; then
		[ ${openblas} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${openblas} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r $sdir $bdir
		pushd $bdir
		(
			# NOTE: setting CFLAGS avoids Openblas to set proper flags
			# NOTE: please do the tests, we have seen openblas giving wrong results for some compilers
			unset CFLAGS
			unset CXXFLAGS
			if [ x${openblas_use_gcc} == xyes ]; then
				run ${MYMAKE} -j $MAKE_JN USE_OPENMP=${openblas_use_openmp} CC=gcc CXX=g++ FC=gfortran
			else
				run ${MYMAKE} -j $MAKE_JN USE_OPENMP=${openblas_use_openmp}
			fi
			run ${MYMAKE} install PREFIX=${idir}
		)
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For openblas
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
	fi
	LIBS+=" -L${idir}/lib -lopenblas -lm -lpthread"
	LDFLAGS+=" -L${idir}/lib"
	if [ `detect_fortran_compiler` == icx ]; then
		echo -n
	elif [ `detect_fortran_compiler` == gcc -o `detect_fortran_compiler` == nvc -o x${openblas_use_gcc} == xyes ]; then
		if [ "`uname -s`" == "Darwin" ] && command -v gfortran &> /dev/null ; then
			LDFLAGS+=" -L$( dirname $( gfortran -print-file-name=libgfortran.dylib ) )"
		fi
		LIBS+=" -lgfortran"
		[ x${use_openmp} == xyes ] && LIBS+=" -lgomp"
		if [ "`uname -s`" == "Darwin" ] && command -v gfortran &> /dev/null ; then
			[ -f "$( gfortran -print-file-name=libquadmath.dylib )" ] && LIBS+=" -lquadmath"
		fi
	elif [ `detect_fortran_compiler` == icc ]; then
		LIBS+=" -limf -lintlc"
	else
		[ $use_arch == hip ] && LIBS+=" `llvm-config --ldflags`"
		LIBS+=" -lpgmath -lflang -lflangrti -lm"
	fi
	export LD_LIBRARY_PATH="$idir/lib:$LD_LIBRARY_PATH"
fi

case $use_blas in
	mkl*) blas="Intel10_64lp_seq";;
	openblas*) blas="OpenBLAS"; [ x${openblas}x != xx ] && cmake_blas_extra=" -DLAPACK_LIBRARIES=${installdir}/${openblas_install}/lib/libopenblas.a -DBLAS_openblas_LIBRARY=${installdir}/${openblas_install}/lib/libopenblas.a";;
	atlas*) blas="ATLAS";;
esac
CMAKE_EXTRA_FLAGS="-DBLA_STATIC=ON -DBLA_VENDOR=$blas $cmake_blas_extra $CMAKE_EXTRA_FLAGS" 

if [ x${gsl}x != xx ]; then
	gsl_install="${gsl_src}"
	sdir="${srcdir}/${gsl_src}"
	bdir="${builddir}/${gsl_install}"
	idir="${installdir}/${gsl_install}"
	info "Doing ${gsl} gsl; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${gsl} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${gsl} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --disable-shared --enable-static --with-pic
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS="-L${idir}/lib -lgsl -lgslcblas -lm -ldl $LIBS"
	LD_LIBRARY_PATH+=":${idir}"
	PKG_CONFIG_PATH+=":${idir}/lib/pkgconfig"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For gsl
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
	fi
fi


if [ x${boost}x != xx ]; then
	boost_install="boost"
	sdir="${srcdir}/${boost_src}"
	info "Doing ${boost} boost; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${boost} == clean ] && rm -rf $sdir
	fi
fi

if [ x${tensor}x != xx ]; then
	tensor_install="tensor"
	sdir="${srcdir}/${tensor_src}"
	bdir="${builddir}/${tensor_install}"
	idir="${installdir}/${tensor_install}"
	info "Doing ${tensor} tensor; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${tensor} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${tensor} == install -o ! -d ${idir} ]; then
		( cd $sdir && run bash autogen.sh )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		# Hack for hadron
		[ x${use_openmp}x != xnopx ] && CXXFLAGS+=" -DHAVE_OPENMP"
		[ x${use_openmp}x != xnopx ] && CFLAGS+=" -DHAVE_OPENMP"
		pushd $bdir
		case "`detect_compiler`" in
		icc) run ${sdir}/configure --prefix=${idir} --without-arpack $tensor_extra_opts CC=icc CXX=icpc ;;
		*)   run ${sdir}/configure --prefix=${idir} --without-arpack $tensor_extra_opts F77=$FC ;;
		esac
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${gmp}x != xx ]; then
	gmp_install="${gmp_src}"
	sdir="${srcdir}/${gmp_src}"
	bdir="${builddir}/${gmp_install}"
	idir="${installdir}/${gmp_install}"
	info "Doing ${gmp} gmp; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${gmp} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${gmp} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --enable-cxx --disable-shared --with-pic CC=gcc CXX=g++ CFLAGS= CXXFLAGS= LDFLAGS= LIBS=
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS+=" -L${idir}/lib -lgmpxx -lgmp"
fi

if [ x${libxml2}x != xx ]; then
	libxml2_install="${libxml2_src}"
	sdir="${srcdir}/${libxml2_src}"
	bdir="${builddir}/${libxml2_install}"
	idir="${installdir}/${libxml2_install}"
	info "Doing ${libxml2} libxml2; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${libxml2} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${libxml2} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --disable-shared --enable-static --with-pic --without-python --without-http --without-html --without-lzma --without-zlib
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS="-L${idir}/lib -lxml2 $LIBS"
	LD_LIBRARY_PATH="${idir}/lib:$LD_LIBRARY_PATH"
	PKG_CONFIG_PATH="${idir}/lib/pkgconfig:$PKG_CONFIG_PATH"
	PATH="${idir}/bin:$PATH"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For libxml2
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="$idir/lib/pkgconfig:\$PKG_CONFIG_PATH"
EOF
	fi
fi

if [ x${hdf5}x != xx ]; then
	hdf5_install="${hdf5_src}"
	sdir="${srcdir}/${hdf5_src}"
	bdir="${builddir}/${hdf5_install}"
	idir="${installdir}/${hdf5_install}"
	info "Doing ${hdf5} hdf5; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${hdf5} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${hdf5} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --disable-shared --enable-static --with-pic --enable-cxx --disable-tests --disable-tools --without-zlib --without-szlib
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS="-L${idir}/lib -lhdf5 -lhdf5_cpp -lhdf5_hl -lhdf5_hl_cpp -ldl $LIBS"
	LD_LIBRARY_PATH+=":${idir}"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For hdf5
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
	fi
fi

if [ x${libfuse3}x != xx ]; then
	libfuse3_install="${libfuse3_src}"
	sdir="${srcdir}/${libfuse3_src}"
	bdir="${builddir}/${libfuse3_install}"
	idir="${installdir}/${libfuse3_install}"
	info "Doing ${libfuse3} libfuse3; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${libfuse3} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${libfuse3} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run $PYTHON -mvenv $bdir/py3
		(
			. $bdir/py3/bin/activate
			pip install --upgrade pip
			pip install meson
			pip install ninja
			export CC=gcc
			export CXX=g++
			export CFLAGS=
			export CXXFLAGS=
			export LIBS=
			export LDFLAGS=
			export DESTDIR=$idir
			meson setup $sdir
			meson configure  -Dprefix=$idir -Dexamples=false -Dtests=false -Dudevrulesdir=false -Duseroot=false -Dutils=true -Dbackend=ninja -Dsysconfdir=$idir/etc
			ninja install
		)
		popd
	fi
	CFLAGS+=" -I${idir}/include/fuse3"
	CXXFLAGS+=" -I${idir}/include/fuse3"
	LIBS+=" -L${idir}/lib64 -lfuse3"
	LD_LIBRARY_PATH+=":${idir}/lib64"
	PKG_CONFIG_PATH+=":${idir}/lib64/pkgconfig"
	PATH+=":${idir}/bin"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For libfuse
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib64:\$LD_LIBRARY_PATH"
export PKG_CONFIG_PATH="$idir/lib64/pkgconfig:\$PKG_CONFIG_PATH"
EOF
	fi
fi

if [ x${anarchofs}x != xx ]; then
	anarchofs_install="${anarchofs_src}"
	sdir="${srcdir}/${anarchofs_src}"
	bdir="${builddir}/${anarchofs_install}"
	idir="${installdir}/${anarchofs_install}"
	info "Doing ${anarchofs} anarchofs; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${anarchofs} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${anarchofs} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		cp -r $sdir $bdir
		pushd $bdir
		mkdir -p $idir
		cp anarchofs_lib.h $idir/
		popd
	fi
	CXXFLAGS+=" -I${idir}"
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For anarchofs
export PATH="$idir:\$PATH"
EOF
	fi
fi

if [ x${qmp}x != xx ]; then
	qmp_install="qmp"
	use_qmp_cmake="nop"
	[ ${qdp_src} != qdpxx -o x${quda}x != xx ] && use_qmp_cmake="yes"
	[ ${use_qmp_cmake} == yes ] && qmp_install="qmp-cmake"
	sdir="${srcdir}/${qmp_src}"
	bdir="${builddir}/${qmp_install}"
	idir="${installdir}/${qmp_install}"
	info "Doing ${qmp} qmp; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${qmp} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${qmp} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		if [ ${qmp_install} == qmp ]; then
			( cd $sdir && run autoreconf -f )
			run ${sdir}/configure --prefix=${idir} --with-qmp-comms-type=MPI --with-qmp-comms-cflags="" --with-qmp-comms-ldflags="" --with-qmp-comms-libs=""
		else
			# QUDA library for HIP is compiled as shared library to avoid a bug, which requies
			# qmp to be compiled with fPIC flags
			CFLAGS="$CFLAGS -fPIC" \
			CXXFLAGS="$CXXFLAGS -fPIC" \
			run cmake \
				-DCMAKE_INSTALL_PREFIX=${idir} \
				-DBUILD_TESTING=OFF \
				-DQMP_MPI=ON \
				-DQMP_TIMING=OFF \
				${CMAKE_EXTRA_FLAGS} \
				${sdir}
		fi
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qdp}x != xx ]; then
	qdp_prec="double"
	[ ${use_float} == yes ] && qdp_prec="single"
	sdir="${srcdir}/${qdp_src}"
	if [ $do_cleaning == nop -a $use_arch == cuda -a $use_qdpjit == yes ]; then
		run rm -rf ${tmp}/h
		run mkdir -p ${tmp}/h
		run cp ${CUDADIR}/nvvm/libdevice/libdevice*bc ${tmp}/h/libdevice.bc
		( cd $sdir && run bash ./pack_libdevice.sh ${tmp}/h )
	fi
	use_qdp_cmake="nop"
	[ $use_qdpjit == yes -o x${quda}x != xx ] && use_qdp_cmake="yes"
	qdp_extra=""
	if [ $use_qdpjit == yes ]; then
		case $use_arch in
		cuda)
			qdp_extra+=" -DQDP_ENABLE_BACKEND=CUDA -DQDP_ALIGNMENT_SIZE=128"
			# Force qdpjit to properly handle contexts
			CXXFLAGS+=" -DQDP_THRUSTALIGN"
			;;
		hip)
			qdp_extra+=" -DQDP_ENABLE_BACKEND=ROCM -DGPU_TARGETS=${AMDGPU_TARGETS} -DAMDGPU_TARGETS=$AMDGPU_TARGETS -DQDP_PROP_OPT=OFF -DROCM_PATH=`$HIPCONFIG -R`"
        		rocm_ver="`hipconfig --version`"
        		case $rocm_ver in
			5.1*) qdp_extra+=" -DQDP_ROCM5FIX=ON -DQDP_ROCM_PRE=ON" ;;
			5.0*|4.*) qdp_extra+=" -DQDP_ROCM_PRE=ON" ;;
			5.5*) qdp_extra+=" -DQDP_ROCM553FIX=ON" ;;
        		esac
			[ x${llvm} != x ] && qdp_extra+=" -DLLVM_DIR=${installdir}/${llvm_install}/lib/cmake/llvm"
			[ x${llvm} != x ] && qdp_extra+=" -DLLD_DIR=${installdir}/${llvm_install}/lib/cmake/lld"
			;;
		esac
        	llvm_ver="`llvm-config --version`"
        	case $llvm_ver in
		14*) qdp_extra+=" -DQDP_ENABLE_LLVM14=ON" ;;
		15*) qdp_extra+=" -DQDP_ENABLE_LLVM15=ON" ;;
		16*) qdp_extra+=" -DQDP_ENABLE_LLVM16=ON" ;;
		17*) qdp_extra+=" -DQDP_ENABLE_LLVM17=ON" ;;
		18*) qdp_extra+=" -DQDP_ENABLE_LLVM18=ON" ;;
        	esac
	fi
	qdp_openmp_flag="--disable-openmp"
	qdp_cmake_openmp="-DQDP_ENABLE_OPENMP=OFF"
	[ x${use_openmp} == xyes ] && qdp_openmp_flag="--enable-openmp" && qdp_cmake_openmp="-DQDP_ENABLE_OPENMP=ON"

	for qdp_nd in 3 4 ; do
		qdp_install="${qdp_src}-${qdp_prec}-nd${qdp_nd}"
		[ ${use_qdp_cmake} == yes ] && qdp_install+="-cmake"
		bdir="${builddir}/${qdp_install}"
		idir="${installdir}/${qdp_install}"
		info "Doing ${qdp} QDP nd=$qdp_nd; source=$sdir build=$bdir install=$idir"
		if [ $do_cleaning == yes ]; then
			[ ${qdp} == clean ] && rm -rf $sdir $bdir $idir
		elif [ ${qdp} == install -o ! -d ${idir} ]; then
			run rm -rf $bdir $idir
			run mkdir -p $bdir
			pushd $bdir
			if [ $qdp_src == qdpxx -a ${use_qdp_cmake} == nop ]; then
				( cd $sdir && run autoreconf -f )
				run ${sdir}/configure \
					--prefix=${idir} \
        				--enable-Nd=$qdp_nd \
				        --enable-parallel-arch=parscalar \
					--enable-precision=${qdp_prec} \
					--enable-filedb \
					--disable-generics \
					--enable-parallel-io \
					--enable-alignment=64 \
					--with-qmp=${installdir}/${qmp_install} \
				        ${qdp_openmp_flag}
			else
				run cmake \
					-DCMAKE_INSTALL_PREFIX=${idir} \
					-DQDP_BUILD_EXAMPLES=OFF \
					-DQDP_PARALLEL_ARCH=parscalar \
					-DQDP_ND=$qdp_nd \
					-DQDP_PRECISION=${qdp_prec} \
					${qdp_cmake_openmp} \
					-DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP \
					$qdp_extra \
					${CMAKE_EXTRA_FLAGS} \
					${sdir}
			fi
			run ${MYMAKE} install -j $MAKE_JN
			popd
		fi
	done
	qdp_install="${qdp_src}-${qdp_prec}-nd4"
	[ ${use_qdp_cmake} == yes ] && qdp_install+="-cmake"
	qdp3d_install="${qdp_src}-${qdp_prec}-nd3"
	[ ${use_qdp_cmake} == yes ] && qdp3d_install+="-cmake"
	if [ $use_qdpjit == yes ]; then
		export LD_LIBRARY_PATH="${installdir}/${qdp_install}/lib:$LD_LIBRARY_PATH"
		if [ x${do_export_env}x != xx ]; then
			cat << EOF >> $do_export_env
# For qdp-jit
export LD_LIBRARY_PATH="${installdir}/${qdp_install}/lib:\$LD_LIBRARY_PATH"
EOF
		fi
	fi
fi

if [ x${quda}x != xx ]; then
	quda_install="${quda_src}-${qdp_install}"
	sdir="${srcdir}/${quda_src}"
	bdir="${builddir}/${quda_install}"
	idir="${installdir}/${quda_install}"
	info "Doing ${quda} QUDA; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${quda} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${quda} == install -o ! -d ${idir} ]; then
		build_type="RELEASE"
		[ $use_opt == debug ] && build_type="DEBUG"
		if [ $use_arch != hip ]; then
			quda_extra_args="\
				-DQUDA_TARGET_TYPE=CUDA \
				-DQUDA_GPU_ARCH=$SM \
				-DCMAKE_CUDA_ARCHITECTURES=${SM#sm_} \
				-DQUDA_BUILD_SHAREDLIB=OFF \
				-DCMAKE_C_COMPILER=${CC} \
				-DCMAKE_CXX_COMPILER=${CXX} \
				-DCMAKE_LINKER=${CXX} \
				-DCMAKE_EXE_LINKER_FLAGS=-L${CUDADIR} \
			"
		else
			quda_extra_args="\
				-DQUDA_TARGET_TYPE=HIP \
				-DAMDGPU_TARGETS=$AMDGPU_TARGETS -DGPU_TARGETS=$AMDGPU_TARGETS \
				-DQUDA_GPU_ARCH=$AMDGPU_TARGETS \
				-DQUDA_BUILD_SHAREDLIB=ON \
				-DMPI_C_COMPILER=${CC} \
				-DMPI_CXX_COMPILER=${CXX} \
				-DROCM_PATH=`$HIPCONFIG -R`"
			# Avoid compiling issue in QUDA
			quda_extra_args+=" -DQUDA_OPENMP=OFF"
		fi
		quda_extra_args+=" -DQUDA_QMP=ON -DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP"
		[ $use_qdpjit == yes ] && quda_extra_args+=" -DQUDA_QDPJIT=ON -DQUDA_INTERFACE_QDPJIT=ON"
		quda_extra_args+=" -DQUDA_INTERFACE_QDP=ON -DQDPXX_DIR=${installdir}/${qdp_install}/lib/cmake/QDPXX"

		# Hack, avoid downloading files
		sed '/./{H;$!d} ; x ; s/file([^)]*)/# ups/' -i ${sdir}/cmake/CPM.cmake
		ln -s -f $srcdir/cpm/cmake/CPM.cmake $srcdir/cpm/CPM_0.40.2.cmake

		# Hack, remove cmake complain
		sed 's@target_include_directories(quda PUBLIC ${ROCM_PATH}/hipfft/include)@# ups@' -i ${sdir}/lib/targets/hip/target_hip.cmake

		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		CFLAGS_quda=${CFLAGS//--craype-append-opt=-?openmp/}
		CFLAGS_quda=${CFLAGS_quda//-?openmp/}
		CXXFLAGS_quda=${CXXFLAGS//--craype-append-opt=-?openmp/}
		CXXFLAGS_quda=${CXXFLAGS_quda//-?openmp/}
		CXXFLAGS_quda=${CXXFLAGS_quda//-std=c++??/}
		LDFLAGS_quda=${LDFLAGS//--craype-append-opt=-?openmp/}
		LDFLAGS_quda=${LDFLAGS_quda//-?openmp/}
		CPM_SOURCE_CACHE=${srcdir} CFLAGS="${CFLAGS_quda}" CXXFLAGS="${CXXFLAGS_quda}" LDFLAGS="${LDFLAGS_quda}" run cmake  \
			-DQUDA_DIRAC_CLOVER=ON \
			-DQUDA_DIRAC_CLOVER_HASENBUSCH=OFF \
			-DQUDA_DIRAC_DOMAIN_WALL=OFF \
			-DQUDA_MDW_FUSED_LS_LIST="8" \
			-DQUDA_DIRAC_NDEG_TWISTED_MASS=OFF \
			-DQUDA_DIRAC_STAGGERED=OFF \
			-DQUDA_DIRAC_TWISTED_MASS=OFF \
			-DQUDA_DIRAC_TWISTED_CLOVER=OFF \
			-DQUDA_DIRAC_WILSON=ON \
			-DQUDA_DYNAMIC_CLOVER=ON \
			-DQUDA_FORCE_GAUGE=OFF \
			-DQUDA_FORCE_HISQ=OFF \
			-DQUDA_GAUGE_ALG=OFF \
			-DQUDA_GAUGE_TOOLS=OFF \
			-DQUDA_INTERFACE_MILC=OFF \
			-DQUDA_INTERFACE_CPS=OFF \
			-DQUDA_INTERFACE_TIFR=OFF \
			-DQUDA_MAGMA=OFF	\
			-DQUDA_QIO=OFF	\
			-DQUDA_MULTIGRID=ON \
			-DQUDA_MAX_MULTI_BLAS_N=9 \
			-DQUDA_DOWNLOAD_EIGEN=NO \
			-DEIGEN_INCLUDE_DIR=${srcdir}/${eigen_src} \
			-DCMAKE_INSTALL_PREFIX=${idir} \
			-DCMAKE_BUILD_TYPE=$build_type \
			-DQUDA_CTEST_DISABLE_BENCHMARKS=ON \
			-DQUDA_BUILD_ALL_TESTS=OFF \
			$quda_extra_args \
			${CMAKE_EXTRA_FLAGS} \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN

		# Avoid QUDA injecting HIP language into anything linked with it
		[ $use_arch == hip ] && sed -i 's/;HIP//' ${idir}/lib/cmake/QUDA/QUDATargets-release.cmake
		[ $use_arch == hip ] && sed -i 's/enable_language(HIP)//' ${idir}/lib/cmake/QUDA/find_target_hip_dependencies.cmake
		popd
	fi
	if [ $use_arch == hip ]; then
		export LD_LIBRARY_PATH="$idir/lib:$LD_LIBRARY_PATH"
		if [ x${do_export_env}x != xx ]; then
			cat << EOF >> $do_export_env
# For quda
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
		fi
	fi
fi

if [ x${mugiq}x != xx ]; then
	mugiq_install="${mugiq_src}-${quda_install}"
	sdir="${srcdir}/${mugiq_src}"
	bdir="${builddir}/${mugiq_install}"
	idir="${installdir}/${mugiq_install}"
	info "Doing ${mugiq} mugiq; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mugiq} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mugiq} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		cmake  \
			-DMUGIQ_GPU_ARCH=$SM \
			-DMUGIQ_QUDA=ON \
			-DMUGIQ_QUDA_SOURCE=${srcdir}/${quda_src} \
			-DMUGIQ_QUDA_HOME=${installdir}/${quda_install} \
			-DMUGIQ_MAGMA=OFF       \
			-DCMAKE_COMMS_TYPE=QMP \
			-DMUGIQ_QMP_HOME=${installdir}/${qmp_install} \
			-DMUGIQ_QIO=ON \
			-DMUGIQ_QIO_HOME=${installdir}/${qdp_install} \
			-DMUGIQ_LIME_HOME=${installdir}/${qdp_install} \
			-DCMAKE_INSTALL_PREFIX=${idir} \
			-DCMAKE_BUILD_TYPE=DEVEL \
			-DCMAKE_CXX_COMPILER=${CXX} \
			-DCMAKE_C_COMPILER=${CC} \
			-DCMAKE_LINKER=${CXX} \
			-DCMAKE_EXE_LINKER_FLAGS="-L${CUDADIR}" \
			-DMUGIQ_BUILD_ALL_TESTS=OFF \
			${CMAKE_EXTRA_FLAGS} \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qphix}x != xx ]; then
	case ${use_march} in
	avx512*|knl|zen4)qphix_isa="avx512";;
	avx2|zen2|zen3) qphix_isa="avx2";;
	avx)            qphix_isa="avx" ;;
	*)
		info "Unsupported architecture for Qphix: $use_march"
		exit 1
		;;
	esac
	qphix_install="${qphix_src}-${qdp_install}-${qphix_isa}"
	sdir="${srcdir}/${qphix_src}"
	bdir="${builddir}/${qphix_install}"
	idir="${installdir}/${qphix_install}"
	info "Doing ${qphix} QPhiX; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${qphix} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${qphix} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		(
		cd $bdir
		py3="${builddir}/jinja2"
		rm -rf $py3
		$PYTHON -mvenv $py3
		. $py3/bin/activate
		pip install --upgrade pip
		$py3/bin/pip install jinja2
		run cmake -Disa=${qphix_isa} \
		      -Dhost_cxx=${CXX} \
		      -Dhost_cxxflags="" \
		      -Drecursive_jN=${MAKE_JN} \
		      -DCMAKE_INSTALL_PREFIX=${idir} \
		      -DQDPXX_DIR=${installdir}/${qdp_install} \
		      -Dclover=TRUE \
		      -Dtm_clover=TRUE \
		      -Dcean=FALSE \
		      -Dqdpalloc=FALSE \
		      -Dqdpjit=FALSE \
		      -Dtesting=OFF \
		      -DPYTHON_EXECUTABLE="$( which python )" \
		      -DPYTHON_INCLUDE_DIR=/usr/include \
		      -DPYTHON_LIBRARY=/usr/lib \
		      ${CMAKE_EXTRA_FLAGS} \
		      ${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		)
	fi
fi

if [ x${magma}x != xx ]; then
	magma_install="magma-${use_arch}"
	sdir="${srcdir}/${magma_src}"
	bdir="${builddir}/${magma_install}"
	idir="${installdir}/${magma_install}"
	info "Doing ${magma} MAGMA; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${magma} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${magma} == install -o ! -d ${idir} ]; then
		if [ $use_arch == cpu ]; then
			echo MAGMA has to be compile for CUDA or HIP
			exit 1
		fi

		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		CXXFLAGS="${CXXFLAGS//-std=c++??/}" run cmake -DCMAKE_INSTALL_PREFIX=${idir} \
			-DBUILD_SHARED_LIBS=OFF -DGPU_TARGET=$SM \
			-DUSE_FORTRAN=OFF \
			-DMAGMA_ENABLE_CUDA=ON \
			-DCMAKE_EXE_LINKER_FLAGS="$LIBS" -DLAPACK_LIBRARIES="m $LIBS"\
			${CMAKE_EXTRA_FLAGS} \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${installdir}/${magma_install}/include"
	CXXFLAGS+=" -I${installdir}/${magma_install}/include"
	LIBS="${installdir}/${magma_install}/lib/libmagma.a $LIBS"
fi


if [ x${primme}x != xx ]; then
	primme_install="primme-${use_arch}"
	sdir="${srcdir}/${primme_src}"
	bdir="${builddir}/${primme_install}"
	idir="${installdir}/${primme_install}"
	info "Doing ${primme} PRIMME; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${primme} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${primme} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r ${srcdir}/${primme_src} $bdir
		case $use_arch in
		cpu)
			run $MYMAKE -C ${bdir} lib install_static PREFIX=${idir} -j $MAKE_JN CC="$CXX" CFLAGS="$CXXFLAGS -fPIC" ;;
		cuda)
			run $MYMAKE -C ${bdir} lib install_static PREFIX=${idir} -j $MAKE_JN CC="$CXX" CFLAGS="$CXXFLAGS -fPIC" CUDADIR="$CUDADIR" ;;
		hip)
			run $MYMAKE -C ${bdir} lib install_static PREFIX=${idir} -j $MAKE_JN CC="$CXX" CFLAGS="$CXXFLAGS -fPIC" ROCMDIR="`$HIPCONFIG -R`" ;;
		esac
		run rm -f ${idir}/lib/libprimme.so*
		run cp ${bdir}/lib/libprimme.a ${idir}/lib
	fi
	CFLAGS+=" -I${installdir}/${primme_install}/include"
	CXXFLAGS+=" -I${installdir}/${primme_install}/include"
	LIBS="-L${installdir}/${primme_install}/lib -lprimme $LIBS"
fi

if [ x${xsimd}x != xx ]; then
	xsimd_install="xsimd"
	sdir="${srcdir}/${xsimd_src}"
	info "Doing ${xsimd} xsimd; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${xsimd} == clean ] && rm -rf $sdir
	fi
fi

if [ x${superbblas}x != xx ]; then
	superbblas_install="superbblas-cpu"
	[ $use_arch == cuda ] && superbblas_install="superbblas-cuda"
	[ $use_arch == hip ] && superbblas_install="superbblas-hip"
	[ $use_superb_next == yes ] && superbblas_install+="-next"
	sdir="${srcdir}/${superbblas_src}"
	bdir="${builddir}/${superbblas_install}"
	idir="${installdir}/${superbblas_install}"
	info "Doing ${superbblas} Superbblas; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${superbblas} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${superbblas} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r ${srcdir}/${superbblas_src}/ $bdir
		make_action="install_cpu"
		if [ $use_arch == cuda ]; then
			make_action="install_cuda"
			[ x${thrust}x != xx ] && sb_nvcc_extra="-I${srcdir}/${cub_src} -I${srcdir}/${thrust_src}"
			sb_nvcc_extra+=" -std=c++14"
			[ $use_opt == debug ] && sb_nvcc_extra+=" -G"
			[ $use_opt == opt ] && sb_nvcc_extra+=" -O3"
			export NVCCFLAGS="-x cu -arch=$SM $NVCCFLAGS $sb_nvcc_extra"
		elif [ $use_arch == hip ]; then
			make_action="install_hip"
			hip_arch_flags="$( for arch in ${AMDGPU_TARGETS//;/ }; do echo -n "--offload-arch=$arch "; done )"
			export HIPFLAGS="`$HIPCONFIG -C | tr '\n' ' '` -I`$HIPCONFIG -R`/hipblas/include -I`$HIPCONFIG -R`/hipsparse/include -I`$HIPCONFIG -R`/hipsolver/include $hip_arch_flags"
		fi
		[ $use_blas == mkl-system ] && sb_cxx_extra+=" -DSUPERBBLAS_USE_MKL"
		# Disable the XSIMD implementation for now, the nvidia compiler complains and it isn't used in production for now
		#[ $use_superb_next == yes ] && sb_cxx_extra+=" -DSUPERBBLAS_USE_XSIMD -I${srcdir}/${xsimd_src}/include"
		CXXFLAGS_sb="${CXXFLAGS//--craype-append-opt=/} $sb_cxx_extra"
		[ $use_arch != cpu ] && CXXFLAGS_sb="${CXXFLAGS_sb//-std=c++??/} -std=c++14"
		run $MYMAKE -C ${bdir} -j $MAKE_JN $make_action BUILDDIR=${idir} CXXFLAGS="$CXXFLAGS_sb"
	fi
	# Add flags to compile and link with HIP runtime and to link with clang openmp
	[ $use_arch == hip ] && CXXFLAGS+=" `$HIPCONFIG -C | tr '\n' ' '` -I`$HIPCONFIG -R`/include"
	[ $use_arch == hip ] && LIBS+=" -L`$HIPCONFIG -R`/lib -lrocsolver -lhipsparse -lhipblas -lrocblas -lamdhip64 -lomp"
	# Add anarchofs support
	[ x${anarchofs}x != xx ] && CXXFLAGS+=" -DSUPERBBLAS_USE_ANARCHOFS"
fi

if [ x${mgproto}x != xx ]; then
	mgproto_install="${mgproto_src}-${qphix_install}"
	sdir="${srcdir}/${mgproto_src}"
	bdir="${builddir}/${mgproto_install}"
	idir="${installdir}/${mgproto_install}"
	info "Doing ${mgproto} mgproto; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mgproto} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mgproto} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		mgproto_extra="-DMG_USE_PRIMME=ON -DPRIMME_HOME=${installdir}/${primme_install}"
		cmake \
		    -DMG_USE_KOKKOS=FALSE \
		    -DMG_USE_QPHIX=TRUE \
		    -DQPHIX_DIR=${installdir}/${qphix_install} \
		    -DMG_QPHIX_COMPRESS12=TRUE \
		    -DMG_QPHIX_SOALEN=4 \
		    -DMG_USE_AVX512=FALSE \
		    -DEigen3_DIR=${srcdir}/${eigen_src} \
		    -DKOKKOS_ENABLE_CUDA=FALSE \
		    -DCMAKE_INSTALL_PREFIX=${idir} \
		    -DQDPXX_DIR=${installdir}/${qdp_install} \
		    -DBUILD_TESTING=OFF \
		    -DMG_DEFAULT_LOGLEVEL=DEBUG \
		    -DMG_KOKKOS_USE_NEIGHBOR_TABLE=FALSE \
		     $mgproto_extra \
		     ${CMAKE_EXTRA_FLAGS} \
		     ${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${chroma}x != xx ]; then
	if [ $use_mg == nop ]; then
		chroma_install="${chroma_src}-${qdp_install}"
	elif [ $use_arch == cpu ]; then
		chroma_install="${chroma_src}-${mgproto_install}"
	else
		chroma_install="${chroma_src}-${quda_install}"
	fi
	[ x${superbblas}x != xx ] && chroma_install+="-${superbblas_install}"
	sdir="${srcdir}/${chroma_src}"
	bdir="${builddir}/${chroma_install}"
	idir="${installdir}/${chroma_install}"
	info "Doing ${chroma} chroma; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${chroma} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${chroma} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		if [ ${use_qdp_cmake} == nop ]; then
			( cd $sdir && run autoreconf -f )
			if [ x${mgproto}x != xx ]; then
				chroma_extra="\
			        	--with-qphix-solver=${installdir}/${qphix_install} \
			        	--enable-qphix-solver-arch=${qphix_isa} \
			        	--enable-qphix-solver-soalen=4 \
			        	--disable-qphix-solver-compress12 \
			        	--enable-qphix-solver-inner-type=f \
			        	--enable-qphix-solver-inner-soalen=8 \
			        	--with-mg-proto=${installdir}/${mgproto_install}"
			fi
			[ ${use_arch} == cuda ] && chroma_extra+=" --with-cuda=${CUDADIR}"
			[ x${primme}x != xx ] && chroma_extra+=" --with-primme=${installdir}/${primme_install}"
			[ x${superbblas}x != xx ] && chroma_extra+=" --with-superbblas=${installdir}/${superbblas_install}"
			[ $use_next == yes -a x${boost}x != xx ] && chroma_extra+=" --with-boost=${srcdir}/${boost_install}"
			run ${sdir}/configure \
				--prefix=${idir} \
				--with-qdp=${installdir}/${qdp_install} \
				--with-qmp=${installdir}/${qmp_install} \
			        --enable-static-packed-gauge \
			        --enable-fused-clover-deriv-loops \
				$chroma_extra
		else
			chroma_extra=""
			[ $use_arch != cpu -a $use_mg == yes ] && chroma_extra="\
				-DChroma_ENABLE_QUDA=ON \
				-DQUDA_DIR=${installdir}/${quda_install}/lib/cmake/QUDA \
				"
			[ $use_qdpjit == yes ] && chroma_extra+=" -DChroma_ENABLE_JIT_CLOVER=ON"
			[ x${magma}x != xx ] && chroma_extra+=" -DChroma_ENABLE_MAGMA=ON -DMAGMA_DIR=${installdir}/${magma_install}"
			[ x${primme}x != xx ] && chroma_extra+=" -DChroma_ENABLE_PRIMME=ON -DPRIMME_DIR=${installdir}/${primme_install}"
			[ x${superbblas}x != xx ] && chroma_extra+=" -DChroma_ENABLE_SUPERBBLAS=ON -DSUPERBBLAS_DIR=${installdir}/${superbblas_install}"
			[ ${use_next} == yes -a x${boost}x != xx ] && chroma_extra+=" -DChroma_ENABLE_BOOST=ON -DBOOST_DIR=${srcdir}/${boost_install}"
			[ ${use_arch} == hip ] && chroma_extra+=" -DChroma_ENABLE_OPENMP=OFF -DAMDGPU_TARGETS=$AMDGPU_TARGETS -DGPU_TARGETS=$AMDGPU_TARGETS -DROCM_PATH=`$HIPCONFIG -R`"
			[ ${use_arch} == cuda ]  && chroma_extra+=" -DChroma_ENABLE_CUDA=ON"
			[ x${llvm} != x ] && chroma_extra+=" -DLLVM_DIR=${installdir}/${llvm_install}/lib/cmake/llvm"
			[ x${llvm} != x ] && chroma_extra+=" -DLLD_DIR=${installdir}/${llvm_install}/lib/cmake/lld"

			run cmake \
				-DCMAKE_INSTALL_PREFIX=${idir} \
				-DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS $LIBS" \
				-DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP \
				-DQDPXX_DIR=${installdir}/${qdp_install}/lib/cmake/QDPXX \
				-DBLAS_SUFFIX_LINK_FLAGS="$LIBS $chroma_extra_blas" \
				$chroma_extra \
				${CMAKE_EXTRA_FLAGS} \
				${sdir}
		fi
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${adat}x != xx ]; then
	adat_install="${adat_src}"
	[ $use_superb == yes ] && adat_install="${adat_src}-${superbblas_src}"
	sdir="${srcdir}/${adat_src}"
	bdir="${builddir}/${adat_install}"
	idir="${installdir}/${adat_install}"
	info "Doing ${adat} adat; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${adat} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${adat} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		adat_extra=""
		[ $use_superb == yes ] && adat_extra+=" --with-superbblas=${installdir}/${superbblas_install}"
		[ $use_superb == yes -a $use_arch != cpu ] && adat_extra+=" --with-gpu"
		[ $use_mpi == yes ] && adat_extra+=" --enable-mpi"
		run ${sdir}/configure --prefix=${idir} $adat_extra
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${hadron}x != xx ]; then
	hadron_install="${hadron_src}-${use_arch}"
	sdir="${srcdir}/${hadron_src}"
	bdir="${builddir}/${hadron_install}"
	idir="${installdir}/${hadron_install}"
	info "Doing ${hadron} hadron; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${hadron} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${hadron} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		hadron_extra=""
		case $use_arch in
		cpu)
			[ $use_blas == mkl-system ] && hadron_extra+=" --enable-mkl"
			[ $use_blas == openblas -o $use_blas == openblas-system ] && hadron_extra+=" --enable-openblas"
			;;
		cuda)
			hadron_extra+=" --enable-cuda --with-cudasm=${SM#sm_} --with-cuda=${CUDADIR}"
			[ x${CUDADIR_extra}x != xx ] && hadron_extra+=" --with-cublas=${CUDADIR_extra}"
			[ $use_opt == debug ] && hadron_extra+=" NVCCFLAGS=-G"
			[ $use_opt == opt ] && hadron_extra+=" NVCCFLAGS=-O3"
			;;
		hip)
			hadron_extra+=" --enable-rocm --with-rocm=`hipconfig -R` --with-rocmtarget=$AMDGPU_TARGETS"
			[ $use_opt == debug ] && hadron_extra+=" HIPCCFLAGS=-g"
			[ $use_opt == opt ] && hadron_extra+=" HIPCCFLAGS=-O3"
			;;
		esac
		[ x${use_openmp}x != xnopx ] && CXXFLAGS+=" -DHAVE_OPENMP"
		[ x${use_openmp}x != xnopx ] && CFLAGS+=" -DHAVE_OPENMP"
		[ x${use_openmp}x != xnopx ] && hadron_extra+=" --enable-openmp"
		run ${sdir}/configure --prefix=${idir} --with-tensor=${installdir}/${tensor_install} ${hadron_extra}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	else
		[ x${use_openmp}x != xnopx ] && CXXFLAGS+=" -DHAVE_OPENMP"
	fi
fi

if [ x${harom}x != xx ]; then
	harom_install="harom-${qdp3d_install}-${use_arch}"
	sdir="${srcdir}/${harom_src}"
	bdir="${builddir}/${harom_install}"
	idir="${installdir}/${harom_install}"
	info "Doing ${harom} harom; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${harom} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${harom} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-qdp=${installdir}/${qdp3d_install} \
			--enable-experimental-baryon-blas-creation
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${colorvec}x != xx ]; then
	colorvec_install="${colorvec_src}-${hadron_install}-${adat_install}"
	sdir="${srcdir}/${colorvec_src}"
	bdir="${builddir}/${colorvec_install}"
	idir="${installdir}/${colorvec_install}"
	info "Doing ${colorvec} colorvec; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${colorvec} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${colorvec} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		[ $use_mpi == yes ] && colorvec_extra="--enable-mpi"
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-adat=${installdir}/${adat_install} ${colorvec_extra}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${redstar}x != xx ]; then
	redstar_install="${redstar_src}-${colorvec_install}"
	sdir="${srcdir}/${redstar_src}"
	bdir="${builddir}/${redstar_install}"
	idir="${installdir}/${redstar_install}"
	info "Doing ${redstar} redstar; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${redstar} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${redstar} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		[ $use_mpi == yes ] && redstar_extra="--enable-mpi"
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-adat=${installdir}/${adat_install} --with-colorvec=${installdir}/${colorvec_install} $redstar_extra
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	PATH+=":${idir}/bin"
fi

if [ x${analysis}x != xx ]; then
	analysis_install="${analysis_src}"
	sdir="${srcdir}/${analysis_src}"
	bdir="${builddir}/${analysis_install}"
	idir="${installdir}/${analysis_install}"
	info "Doing ${analysis} analysis; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${analysis} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${analysis} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		cp -r $sdir $bdir
		pushd $bdir
		run make PREFIX="${idir}" EIGEN="${srcdir}/${eigen_src}" HDF5_INCLUDE= HDF5_LIBS= GSL_INCLUDE= GSL_LIBS=
		popd
	fi
fi

if [ x${laplace_eigs}x != xx ]; then
	laplace_eigs_install="laplace_eigs-${qdp3d_install}"
	sdir="${srcdir}/${laplace_eigs_src}"
	bdir="${builddir}/${laplace_eigs_install}"
	idir="${installdir}/${laplace_eigs_install}"
	info "Doing ${laplace_eigs} laplace_eigs; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${laplace_eigs} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${laplace_eigs} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p ${idir}
		run cp -r $sdir $bdir
		pushd $bdir
		run ${MYMAKE} ARCH="QMP" PRIMME_ENV=${installdir}/${primme_install} QDP_CONFIG_ND3_ENV=${installdir}/${qdp3d_install}/bin/qdp++-config QDP_CONFIG_ND4_ENV=${installdir}/${qdp_install}/bin/qdp++-config
		run cp laplace_eigs vecs_combine_4d vecs_combine_3d ${idir}
		popd
	fi
fi

# Everything went ok!
# Avoid removing the last installation by function finish
idir=""
