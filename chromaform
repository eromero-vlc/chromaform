#!/bin/bash

## Ultimate script to install chroma ecosystem
##

read -r -d '' hlp_msg << 'EOF'
Script for installing chroma and redstar and related software.

chromaform [--source-dir=dir] [--build-dir=dir] [--install-dir=dir]                       \\
           [--float] [--cuda|--hip] [--mg] [--pdf] [--next] [--superb]                    \\
           [--cmake=build|--cmake=system] [--llvm=build|--llvm=system]                    \\
           [--thrust=build|--thrust=system] [--gmp=build|--gmp=system]                    \\
           [--libxml2=build|--libxml2=system]                                             \\
           [--blas=openblas|--blas=openblas-system|--blas=atlas-system|--blas=mkl]        \\
           [-g|-O|-Onone] [--avx|--avx2|--knl|--avx512|--zen2|--zen3] [--autoflags=no]    \\
           [--std=c++11|--std=c++14|--std=c++20]                                          \\
           [--clean|--install|--update|--download-only] [gcc] [openmpi] [mvapich2]        \\
           [cmake] [llvm] [cub] [thrust] [openblas] [gmp] [libxml2] [eigen] [qmp] [qdp]   \\
           [superbblas] [primme] [magma] [mgproto] [qphix] [quda] [chroma]                \\
           [laplace_eigs] [adat] [colorvec] [tensor] [hadron] [redstar]                   \\
           [CC=...] [CFLAGS=...] [CXX=...] [CXXFLAGS=...] [FC=...] [SM=...]               \\
           [CMAKE_EXTRA_FLAGS=...]

Examples:

# Install chroma with mg_proto/QPhiX
chromaform --mg chroma
# Install chroma with mg_proto/QPhiX with AVX512 support
chromaform --mg --avx512 chroma
# Install chroma with QUDA for arch=sm_70
chromaform --mg --cuda chroma SM=sm_70
# Install redstar and harom
chromaform redstar harom

* Location options:
Each installed package will have an entry in the directories indicated
for keeping the source, the compilation, and the installation. 

--source-dir=<dir> 
   Directory where to put the sources; the default is \$PWD/src.
--build-dir=<dir>
   Directory where to build the packages; the default is \$PWD/build.
--install-dir=<dir>
   Directory where to install the packages; the default is \$PWD/install.

* Package flavor options:
Some packages have special optional features.

--float
   Install the single-precision version; the double precision version is installed
   by default. Used by QDP.
--cuda
   Install the CUDA/JIT version; the CPU version is installed by default. Used by QDP,
   superbblas, and chroma.
--hip
   Install the HIP/JIT version; the CPU version is installed by default. Used by QDP,
   superbblas, and chroma.
--mg
   Install multigrid extension of chroma; it isn't installed by default.
--superb
   Install the superbblas extensions of chroma; it isn't installed by default.
--pdf
   Install the devel-pdf branches of adat, colorvec and redstar; the devel branch is
   installed by default.
--next
   Install upcoming versions of some packages; the version in devel or master is
   installed by default. Used by:
   - chroma: new disconnected diagram task based on frequency splitting.

* CMake, LLVM, BLAS, GMP, LIBXML2:
   Some packages require CMake, LLVM, and BLAS, and this are the options to select
   which implementation to use.

--cmake=[build|system]
   Use the cmake in \$PATH if 'system' is given; otherwise, it builds a recent version.
   By default, it detects the cmake version available, and build cmake if it is not
   recent enough.

--llvm=[build|system]
   Use the LLVM indicated by llvm-config  in \$PATH if 'system' is given; otherwise, it
   builds a recent version. By default, it detects the LLVM version available, and build 
   LLVM if it is not.

--thrust=[build|system]
   Use the cub/thrust in the CUDA SDK if 'system' is given; otherwise, it
   downloads a recent version. By default, it detects the thrust version available, and
   download cub and thrust if it is not.

--blas=[openblas|openblas-system|atlas-system|mkl]
   Build OpenBLAS if 'openblas' is given, or use the system OpenBLAS, ATLAS, or MKL if
   'openblas-system', 'atlas-system', 'mkl' is given, respectively. If using MKL, plase
   set the environ variable MKLROOT. By default, it detects if there are flags in LDFLAGS
   and LIBS suggesting the use of MKL, OpenBLAS, and ATLAS, and use that. Otherwise, it
   uses MKL if MKLROOT is set, or OpenBLAS or ATLAS if they have pkg-config sets
   available.

--gmp=[build|system]
   Use the qmp in the system if 'system' is given; otherwise, it
   downloads a recent version. By default, it detects if they have pkg-config
   configuration available.

--libxml2=[build|system]
   Use the libxml2 in the system if 'system' is given; otherwise, it
   downloads a recent version. By default, it detects if they have pkg-config
   configuration available.

* Compilation flags:
Control the flags use for building the packages.

-g|-O|-Onone
   Append '-g3 -O0' to CFLAGS and CXXFLAGS if '-g' is given, of '-O3' if '-O' is given, 
   or no flags are added if '-Onone' is given. By default, '-O3' is appended.

--avx|--avx2|--knl|--avx512|--zen2|--zen3
   Append flags in CFLAGS and CXXFLAGS to activate proper extensions in the compiler,
   and set the QphiX isa.

--std=c++11|c++14|c++20   
   Append the given flag to CXXFLAGS; --std=c++20 is appended if flag '--hip' or ---cuda'
   is set; otherwise, --std=c++14 is appended by default.

--autoflags=no
   If given, CFLAGS, CXXFLAGS, and LDFLAGS are not modified by the options -g, -O,
   --avx512, --knl, --zen2, --zen3, and --std, or any automatic heuristic in this script.
   By default, besides setting CFLAGS and CXXFLAGS as described, flags are added to
   activate AVX2 and OpenMP compiler extensions.

* Actions and packages:
An action is either of the flags --clean, --install, or --update, and can be followed by
several packages and other actions. The --update action is implied if no other action was
given before. For instance:

  chromaform chroma --install openblas

marks the package chroma with the flag --update and the package openblas with the flag
--install. The actions are described in the following:

--install <pkg> <pkg> ...
   Always download the source code, build, and install the packages marked with this
   action. Mark their dependent packages as --update.
--update <pkg> <pkg> ...
   Download the source code if it is not in the source directory already, and install the
   packages marked with this action if they are not found on the install directory.
   Mark their dependent packages as --update.
--clean <pkg> <pkg> ...
   Remove the instances in the source, build, and install directories of the packages
   marked with this action.

--download-only
   If given, no building nor installation is done, only changes on the source directory
   are going to be performed. This is useful to download all the sources required and
   copy them to a machine without external internet access. 

* Set environ variables:
All input options that are not flags or packages described above and contain '='
will be considered a variable assignation. For instance:

  chromaform chroma CC=icc CXX=icpc PATH=/mypaths:\$PATH

will export the value of the variables CC, CXX, and PATH to subshells and executed
commands.
EOF

srcdir="src"
builddir="build"
installdir="install"
download_only="nop"
do_cleaning="nop"
use_float="nop"
use_arch="cpu"
use_march=""
use_pdf="nop"
use_next="nop"
use_superb="nop"
use_qdpjit="yes"
use_superb_next="nop"
use_mg="nop"
use_llvm=""
use_thrust=""
use_blas=""
use_gmp=""
use_libxml2=""
use_cmake=""
use_autoflags="yes"
use_opt="opt"
use_std=""
do_export_env=""
action="update"

# Jean Zay's frontend does not have much memory and chroma linking fails often
mymake() {
	make "$@" || make "$@" -j 1 || make "$@" -j 1 || make "$@" -j 1 
}

MYMAKE="${MAKE:-mymake}"
[ x${MAKE_JN}x == xx ] && MAKE_JN="$(( (`grep "^processor" /proc/cpuinfo | wc -l` + 2) / 3 ))"
if [ x${CUDADIR}x == xx ] ; then
	CUDADIR="$( realpath $( dirname $( which nvcc ))/..)"
	# If using NVHPC, point out the cuda directory
	if [ x${CUDADIR}x != x${CUDADIR%compilers}x ] ; then
		CUDADIR="$( realpath ${CUDADIR}/../cuda )"
		CUDADIR_extra="$( realpath ${CUDADIR}/../math_libs )"
	fi
fi
SM="${SM:-sm_70}"
AMDGPU_TARGETS="${AMDGPU_TARGETS:-gfx900;gfx906;gfx908}"
tmp="`mktemp -d`"
idir=""

finish() {
	rm -rf $tmp
	# If a make install failed in the middle, remove the whole directory
	[ x${idir}x != xx ] && rm -rf $idir
}
trap finish EXIT

n=$#
for (( i=1 ; i<=n ; ++i )); do
	arg="$1"
	case $arg in
	--source-dir=*) srcdir="${arg#--source-dir=}";;
	--build-dir=*) builddir="${arg#--build-dir=}";;
	--install-dir=*) installdir="${arg#--install-dir=}";;
	--download-only) download_only="yes";;
	--float) use_float="yes";;
	--cpu) use_arch="cpu";;
	--jit|--cuda) use_arch="cuda";;
	--hip) use_arch="hip";;
	--superb) use_superb="yes";;
	--qdpjit=no) use_qdpjit="no";;
	--superb-next) use_superb="yes";use_superb_next="yes";;
	--avx) use_march="avx";;
	--avx2) use_march="avx2";;
	--avx512) use_march="avx512";;
	--knl) use_march="knl";;
	--zen2) use_march="zen2";;
	--zen3) use_march="zen3";;
	--mg) use_mg="yes";;
	--next) use_next="yes";use_superb="yes";use_superb_next="yes";;
	--pdf) use_pdf="yes";;
	--clean) action="clean";do_cleaning="yes";;
	--install) action="install";;
	--update) action="update";;
	--llvm=build) use_llvm="llvm";;
	--llvm=system) use_llvm="llvm-system";;
	--thrust=build) use_thrust="thrust";;
	--thrust=system) use_thrust="thrust-system";;
	--cmake=build) use_cmake="cmake";;
	--cmake=system) use_cmake="cmake-system";;
	--blas=openblas) use_blas="openblas";;
	--blas=openblas-system) use_blas="openblas-system";;
	--blas=atlas-system) use_blas="atlas-system";;
	--blas=mkl) use_blas="mkl-system";;
	--gmp=build) use_gmp="gmp";;
	--gmp=system) use_gmp="gmp-system";;
	--libxml2=build) use_libxml2="libxml2";;
	--libxml2=system) use_libxml2="libxml2-system";;
	--autoflags=no) use_autoflags="nop";;
	--autoflags=yes) use_autoflags="yes";;
	-g) use_opt="debug";;
	-O) use_opt="opt";;
	-Onone) use_opt="nop";;
	--c++11) use_std="c++11";;
	--c++14) use_std="c++14";;
	--c++20) use_std="c++20";;
	--env=*) do_export_env="${arg#--env=}";;
	openblas) openblas="$action";use_blas="openblas";;
	cmake) cmake="$action";use_cmake="cmake";;
	llvm) llvm="$action";use_llvm="llvm";;
	cub) cub="$action";;
	boost) boost="$action";;
	thrust) thrust="$action";use_thrust="thrust";;
	qmp) qmp="$action";;
	qdp) qdp="$action";;
	superbblas) superbblas="$action";;
	qphix) qphix="$action";;
	primme) primme="$action";;
	magma) magma="$action";;
	mgproto) mgproto="$action";;
	quda) quda="$action";;
	mugiq) mugiq="$action";;
	chroma) chroma="$action";;
	laplace_eigs) laplace_eigs="$action";;
	adat) adat="$action";;
	colorvec) colorvec="$action";;
	tensor) tensor="$action";;
	hadron) hadron="$action";;
	harom) harom="$action";;
	redstar) redstar="$action";;
	libxml2) libxml2="$action";use_libxml2="libxml2";;
	gcc) gcc="$action";;
	openmpi) openmpi="$action";;
	mvapich2) mvapich2="$action";;
	*=*) export ${arg%%=*}="${arg#*=}";;
	--help|-h) echo "$hlp_msg"; exit 0;;
	*) echo "Sorry! Unsupported option '$arg'"; echo "$hlp_msg"; exit 1;;
	esac
	shift
done

# Prompting

last_status=0 # Last command status
run() {
	echo "$>" "$@"
	"$@" < /dev/null
	last_status=$?
	if [ $last_status -ne 0 ]; then
		echo "$> last command failed with exit status $last_status"
		exit $last_status
	fi
	return 0
}

info() {
	echo "#>" "$@"
}

check_success() {
	echo "Exit status $last_status"
	[ $last_status -ne 0 ] && exit $last_status
}

# Set default compilers
if [ x${openmpi}x == xx -a x${mvapich2}x == xx ]; then
	CC="${CC:-mpicc}"
	CXX="${CXX:-mpicxx}"
else
	if [ x${CXX} == xmpicxx -o x${CC} == xmpicc ]; then
		echo "When compiling openmpi or mvapich2, please set \$CC and \$CXX to something else other than mpicc and mpicxx"
		exit 1
	fi
fi

# Add extra flags

if [ x${use_std}x == xx ]; then
	use_std="c++14"
	[ $use_arch != cpu -a $use_qdpjit == yes ] && use_std="c++20"
fi

detect_compiler() {
	compiler="any"
	if [ x${gcc}x != xx ]; then
		compiler="gcc"
	elif ( $CXX --version 2>&1 | grep -q '^g++' ); then
		compiler="gcc"
	elif ( $CXX --version 2>&1 | grep -q '^clang version' ); then
		compiler="clang"
	elif ( $CXX --version 2>&1 | grep -q '^nvc' ); then
		compiler="nvc"
	elif ( $CXX -v 2>&1 | grep -q '^icc version' ); then
		compiler="icc"
	elif ( $CXX -v 2>&1 | grep -q '^icpc version' ); then
		compiler="icc"
	fi
	echo $compiler
}

detect_fortran_compiler() {
	compiler="any"
	if [ x${gcc}x != xx -o x${FC}x == xx ]; then
		compiler="gcc"
	elif ( $FC --version 2>&1 | grep -q '^GNU Fortran' ); then
		compiler="gcc"
	elif ( $FC --version 2>&1 | grep -q '^nvfortran' ); then
		compiler="nvc"
	elif ( $FC --version 2>&1 | grep -q 'flang[^ ]* version' ); then
		compiler="flang"
	fi
	echo $compiler
}

if [ ${use_autoflags} == yes ]; then
	info "No CPU architecture given; guessing ..."
	if [ x${use_march}x == xx ]; then
		if grep -q "vendor_id.*AuthenticAMD" /proc/cpuinfo ; then
			info "Detected AMD zen2"
			use_march="zen2"
		elif grep -q "cpu.*:.*POWER" /proc/cpuinfo ; then
			info "Detected POWER architecture"
			use_march="power"
		elif grep -q "vendor_id.*GenuineIntel" /proc/cpuinfo ; then
			if grep -q "avx512" /proc/cpuinfo ; then
				info "Detected intel with avx512 support"
				use_march="avx512"
			elif grep -q "avx2" /proc/cpuinfo ; then
				info "Detected intel with avx2 support"
				use_march="avx2"
			else
				info "Detected intel with avx support"
				use_march="avx"
			fi
		fi
	fi
	if [ ${use_march} == knl ]; then
		# Active special tricks for a special architecture
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xCORE-AVX2 -axCORE-AVX512,MIC-AVX512"
			CFLAGS+=" -xCORE-AVX2 -axCORE-AVX512,MIC-AVX512"
			;;
		*)
			CXXFLAGS+=" -march=knl -mavx512f -mavx512pf -mavx512er -mavx512cd"
			CFLAGS+=" -march=knl -mavx512f -mavx512pf -mavx512er -mavx512cd"
			;;
		esac
	elif [ ${use_march} == avx512 ]; then
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xCORE-AVX2 -axCORE-AVX512"
			CFLAGS+=" -xCORE-AVX2 -axCORE-AVX512"
			;;
		*)
			CXXFLAGS+=" -march=skylake-avx512 -mavx512f -mavx512pf -mavx512er -mavx512cd"
			CFLAGS+=" -march=skylake-avx512 -mavx512f -mavx512pf -mavx512er -mavx512cd"
			;;
		esac
	elif [ ${use_march} == avx2 ]; then
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xCORE-AVX2"
			CFLAGS+=" -xCORE-AVX2"
			;;
		*)
			CXXFLAGS+=" -march=haswell -mavx2"
			CFLAGS+=" -march=haswell -mavx2"
			;;
		esac
	elif [ ${use_march} == avx ]; then
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xCORE-AVX"
			CFLAGS+=" -xCORE-AVX"
			;;
		*)
			CXXFLAGS+=" -march=ivybridge -mavx"
			CFLAGS+=" -march=ivybridge -mavx"
			;;
		esac
	elif [ ${use_march} == zen2 ]; then
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xaCORE-AVX2"
			CFLAGS+=" -xaCORE-AVX2"
			;;
		*)
			CXXFLAGS+=" -march=znver2"
			CFLAGS+=" -march=znver2"
			;;
		esac
	elif [ ${use_march} == zen3 ]; then
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xaCORE-AVX2"
			CFLAGS+=" -xaCORE-AVX2"
			;;
		*)
			CXXFLAGS+=" -march=znver3"
			CFLAGS+=" -march=znver3"
			;;
		esac
	elif [ ${use_march} == power ]; then
		info "Not setting specific architecture flags for POWER architecture"
	fi
	if ! ( echo ${CXXFLAGS} | grep -q openmp ); then
		# QDP is compiled with OpenMP, so we need to add the flag
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -qopenmp"
			CFLAGS+=" -qopenmp"
			LDFLAGS+=" -qopenmp"
			;;
		*)
			CXXFLAGS+=" -fopenmp"
			CFLAGS+=" -fopenmp"
			LDFLAGS+=" -fopenmp"
			;;
		esac
	fi
	case ${use_opt} in
	debug)
		CFLAGS+=" -g3 -O0"
		CXXFLAGS+=" -g3 -O0"
		LDFLAGS+=" -g3 -O0"
		CMAKE_EXTRA_FLAGS+=" -DCMAKE_INTERPROCEDURAL_OPTIMIZATION=OFF"
		;;
	opt)
		CFLAGS+=" -O3"
		CXXFLAGS+=" -O3"
		LDFLAGS+=" -O3"
		;;
	esac
	case "$CXXFLAGS" in
	*-std=*) ;;
	*) CXXFLAGS+=" -std=$use_std" ;;
	esac
	# Old versions of icc need this
	case "$CFLAGS" in
	*-std=*) ;;
	*) CFLAGS+=" -std=c11 -D_XOPEN_SOURCE=500" ;;
	esac
elif [ x${use_march}x = xx ] ; then
	info "No architecture information given, just assuming AVX"
	use_march="avx"
fi

# If the user gives BLAS options LDFLAGS or LIBS, use them.
# Otherwise, try to detect an available BLAS on the system,
# or compile OpenBLAS

if [ x${use_blas}x == xx ]; then
	info "No BLAS suggestion give; detecting BLAS..."
	case "$LDFLAGS $LIBS" in
	*libmkl*|*-mkl*) use_blas="mkl-system";;
	*openblas*) use_blas="openblas-system";;
	*atlas*) use_blas="atlas-system";;
	*)
		if [ x${openblas}x != xx ]; then
			use_blas="openblas"
		elif [ x${MKLROOT}x != xx ]; then
			use_blas="mkl-system"
			CFLAGS+=" -I${MKLROOT}/include"
			CXXFLAGS+=" -I${MKLROOT}/include"
			LIBS+=" -L${MKLROOT}/lib/intel64 -Wl,--no-as-needed -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -liomp5 -lpthread -lm -ldl"
		elif pkg-config --cflags openblas ; then
			use_blas="openblas-system"
			CFLAGS+=" `pkg-config --cflags openblas`"
			CXXFLAGS+=" `pkg-config --cflags openblas`"
			LIBS+=" `pkg-config --libs --static openblas`"
		elif pkg-config --cflags atlas ; then
			use_blas="atlas-system"
			CFLAGS+=" `pkg-config --cflags atlas`"
			CXXFLAGS+=" `pkg-config --cflags atlas`"
			LIBS+=" `pkg-config --libs atlas`"
		else
			use_blas="openblas"
		fi
	;;
	esac
fi

# Detect GMP

if [ x${use_gmp}x == xx ]; then
	info "No GMP suggestion give; detecting GMP..."
	case "$LDFLAGS $LIBS" in
	*gmp*) use_gmp="gmp-system";;
	*)
		if [ x${gmp}x != xx ]; then
			use_gmp="gmp"
		elif pkg-config --libs gmpxx &> /dev/null || [ -f /usr/include/gmpxx.h ]; then
			use_gmp="gmp-system"
		else
			use_gmp="gmp"
		fi
		;;
	esac
fi
if [ ${use_gmp} == "gmp-system" ]; then
	case "$LDFLAGS $LIBS" in
	*gmp*)
		# Do nothing
		;;
	*)
		if pkg-config --libs gmpxx &> /dev/null ; then
			LIBS+=" `pkg-config --libs gmpxx`"
	        else
			# Wild guessing
			LIBS+=" -lgmpxx -lgmp"
		fi
		;;
	esac
fi

# Detect libxml2

if [ x${use_libxml2}x == xx ]; then
	info "No libxml2 suggestion give; detecting libxml2..."
	case "$LDFLAGS $LIBS" in
	*xml2*) use_libxml2="libxml2-system";;
	*)
		if [ x${libxml2}x != xx ]; then
			use_libxml2="libxml2"
		elif pkg-config --libs libxml-2.0 &> /dev/null ; then
			use_libxml2="libxml2-system"
		else
			use_libxml2="libxml2"
		fi
		;;
	esac
fi
if [ ${use_libxml2} == "libxml2-system" ]; then
	case "$LDFLAGS $LIBS" in
	*xml2*)
		# Do nothing
		;;
	*)
		if pkg-config --libs libxml-2.0 &> /dev/null ; then
			CFLAGS+=" `pkg-config --cflags libxml-2.0`"
			CXXFLAGS+=" `pkg-config --cflags libxml-2.0`"
			LIBS+=" `pkg-config --libs libxml-2.0`"
		else
			# Wild guessing
			CFLAGS+=" -I/usr/include/libxml2"
			CXXFLAGS+=" -I/usr/include/libxml2"
			LIBS+=" -lxml2"
		fi
		;;
	esac
fi

# Detect if there is a cmake available in case the user does not give a clue

if [ x${use_cmake}x == xx ]; then
	info "No cmake suggestion given; detecting cmake version..."
	use_cmake="cmake"
	if cmake --version &> /dev/null ; then
		cmake_version="`cmake --version 2>&1  | grep "^cmake version" | tr . ' '`"
		ver_maj="`echo $cmake_version | while read a a ver_maj ver_minor a ; do echo $ver_maj; done`"
		ver_minor="`echo $cmake_version | while read a a ver_maj ver_minor a ; do echo $ver_minor; done`"
		( [ $use_arch != hip -a $ver_maj -ge 3 -a $ver_minor -ge 18 ] || [ $use_arch == hip -a $ver_maj -ge 3 -a $ver_minor -ge 21 ] ) && use_cmake="cmake-system"
	fi
fi

# Add hipconfig -l into the PATH

if [ $use_arch == hip ]; then
	[ x${HIPCONFIG}x == xx ] && HIPCONFIG="$( which hipconfig )"
	export PATH="$PATH:`$HIPCONFIG -l`"
fi

# Detect if there is a LLVM available in case the user does not give a clue

if [ x${use_llvm}x == xx ]; then
    if [ x${llvm}x != xx ]; then
        use_llvm="llvm"
    elif llvm-config --version &> /dev/null ; then
        llvm_ver="`llvm-config --version`"
        case $llvm_ver in
	13*|14*|15*) use_llvm="llvm-system" ;;
        *)           use_llvm="llvm";;
        esac
    else
        use_llvm="llvm"
    fi
fi

# Detect if there is thrust available in case the user does not give a clue.
# The first good version is provided with CUDA 12 and HIP 5.4

if [ x${use_thrust}x == xx ]; then
	if [ x${thrust}x != xx ]; then
		use_thrust="thrust"
	elif [ $use_arch == hip ]; then
        	rocm_ver="`hipconfig --version`"
        	case $rocm_ver in
		4.*|5.0*|5.1*|5.2*|5.3*) use_thrust="thrust" ;;
		*) use_thrust="thrust-system" ;;
        	esac
	elif [ $use_arch == cuda ]; then
		cuda_version="`nvcc -V | sed -n 's/^.*release \([^.]\+\).*$/\1/p'`"
		if [ $cuda_version -lt 12 ]; then
			use_thrust="thrust"
		else
			use_thrust="thrust-system"
		fi
	else
		use_thrust="thrust"
	fi
fi

# MAGMA and other packages have problems to find cuda libraries when using NVHPC; so we help them
if [ x${CUDADIR_extra}x != xx ]; then
	CMAKE_EXTRA_FLAGS+="
		-DCUDA_cublas_LIBRARY=${CUDADIR_extra}/lib64/libcublas.so
		-DCUDA_cublas_device_LIBRARY=${CUDADIR_extra}/lib64/libcublasLt.so
		-DCUDA_cusolver_LIBRARY=${CUDADIR_extra}/lib64/libcusolver.so
		-DCUDA_cusparse_LIBRARY=${CUDADIR_extra}/lib64/libcusparse.so
		-DCUDA_nppi_LIBRARY=${CUDADIR_extra}/lib/lib64/libnppial.so"
	CFLAGS+=" -I${CUDADIR_extra}/include" 
	CXXFLAGS+=" -I${CUDADIR_extra}/include"
	LDFLAGS+=" -L${CUDADIR_extra}/lib64"
fi

# Print basic variables

info "Using PATH: $PATH"
info "Using CUDADIR: $CUDADIR"
info "Using CUDADIR_extra: $CUDADIR_extra"
info "Using cmake: ${use_cmake}"
info "Using llvm: ${use_llvm}"
info "Using thrust: ${use_thrust}"
info "Using BLAS: ${use_blas}"
info "Using GMP: ${use_gmp}"
info "Using libxml2: ${use_libxml2}"
info "Using CC=$CC"
info "Using CFLAGS=$CFLAGS"
info "Using CXX=$CXX"
info "Using CXXFLAGS=$CXXFLAGS"
info "Using FC=$FC"
info "Using LDFLAGS=$LDFLAGS"
info "Using LIBS=$LIBS"
export CC CFLAGS CXX CXXFLAGS FC LDFLAGS LIBS

# Process dependencies

if [ $use_arch == cpu ]; then
	[ $use_mg == yes -a x${chroma}x != xx ] && mgproto="${mgproto:-update}"
	[ x${mgproto}x != xx ] && qphix="${qphix:-update}"
	[ x${mgproto}x != xx ] && primme="${primme:-update}"
else
	[ $use_mg == yes -a x${chroma}x != xx ] && quda="${quda:-update}"
	#[ $use_mg == yes -a $use_next == yes ] && mugiq="${mugiq:-update}"
fi
[ x${quda}x != xx -a $use_arch == hip ] && cpm="${cpm:-update}"
[ x${mugiq}x != xx ] && quda="${quda:-update}"
[ x${chroma}x != xx -a $use_superb == yes ] && superbblas="${superbblas:-update}"
[ x${chroma}x != xx -a $use_next == yes ] && boost="${boost:-update}"
[ x${chroma}x != xx -a x${superbblas}x != xx ] && primme="${primme:-update}"
[ x${mgproto}x != xx ] && primme="${primme:-update}"
[ x${qphix}${mgproto}${quda}${chroma}${laplace_eigs}x != xx ] && qdp="${qdp:-update}"
[ x${qphix}${quda}x != xx ] && eigen="${eigen:-update}"

[ x${laplace_eigs}x != xx ] && primme="${primme:-update}"
[ x${redstar}x != xx ] && hadron="${hadron:-update}" && adat="${adat:-update}" && colorvec="${colorvec:-update}"
[ x${adat}${gcc}x != xx -a ${use_gmp} == gmp ] && gmp="${gmp:-update}"
[ x${colorvec}x != xx ] && hadron="${hadron:-update}" && adat="${adat:-update}"
[ x${harom}x != xx ] && hadron="${hadron:-update}" && qdp="${qdp:-update}"
[ x${hadron}x != xx ] && tensor="${tensor:-update}"
[ x${qdp}x != xx ] && qmp="${qmp:-update}"

[ $use_arch != cpu -a x${qdp}x != xx -a ${use_qdpjit} == yes -a $use_llvm == llvm ] && llvm="${llvm:-update}"
[ x${tensor}${primme}${superbblas}${mgproto}${chroma}x != xx -a $use_blas == openblas ] && openblas="${openblas:-update}"
[ x${primme}x != xx -a $use_arch == cuda ] && magma="${magma:-update}"
[ x${superbblas}x != xx -a $use_blas == openblas ] && openblas="${openblas:-update}"
if [ $use_blas != openblas -a x${openblas}x != xx ]; then
	echo "Incompatible options: --blas!=openblas but also asking for compiling openblas"
	exit 1
fi
if [ $use_arch != cpu -a x${laplace_eigs}${harom}x != xx ]; then
	echo "Incompatible options: --cuda or --hip cannot be use while targeting laplace_eigs or harom"
	exit 1
fi
[ $use_arch != cpu -a x${superbblas}${quda}x != xx -a $use_thrust == thrust ] && thrust="${thrust:-update}"
[ x${thrust}x != xx -a $use_arch == cuda ] && cub="${cub:-update}"
[ x${thrust}x != xx -a $use_arch == hip ] && prim="${prim:-update}"
if [ $use_thrust != thrust -a x${thrust}x != xx ]; then
	echo "Incompatible options: --thrust=system but also asking for compiling thrust"
	exit 1
fi
[ x${qdp}x != xx -a $use_libxml2 == libxml2 ] && libxml2="${libxml2:-update}"
[ x${adat}x != xx -a $use_libxml2 == libxml2 ] && libxml2="${libxml2:-update}"
if [ $use_libxml2 != libxml2 -a x${libxml2}x != xx ]; then
	echo "Incompatible options: --libxml2=system but also asking for compiling libxml2"
	exit 1
fi

[ x${llvm}${qphix}${mgproto}${quda}${mugiq}${magma}x != xx -a $use_cmake == cmake ] && cmake="${cmake:-update}"

[ x${gcc}x != xx -a x${mpfr}x == xx ] && mpfr="${mpfr:-update}"
[ x${gcc}x != xx -a x${isl}x == xx ] && isl="${isl:-update}"
[ x${gcc}x != xx -a x${mpc}x == xx ] && mpc="${mpc:-update}"
[ x${openmpi}x != xx -a x${ucx}x == xx ] && ucx="${ucx:-update}"

# Download

mkdir -p $srcdir
srcdir="`realpath $srcdir`"
info "Source directory: $srcdir"

if [ x${qmp}x != xx ]; then
	qmp_src="qmp"
fi
if [ x${qdp}x != xx ]; then
	qdp_src="qdpxx"
	[ $use_arch != cpu -a $use_qdpjit == yes ] && qdp_src="qdp-jit"
fi
if [ x${quda}x != xx ]; then
	quda_src="quda"
	cpm_src="cpm"
	#[ $use_next == yes ] && quda_src="quda-mugiq"
fi
if [ x${mugiq}x != xx ]; then
	mugiq_src="mugiq"
fi
if [ x${qphix}x != xx ]; then
	qphix_src="qphix"
fi
if [ x${mgproto}x != xx ]; then
	mgproto_src="mgproto"
fi
if [ x${chroma}x != xx ]; then
	chroma_src="chroma"
	if [ $use_next == yes ]; then
		chroma_src="chroma-fs-sp"
	elif [ $use_superb_next == yes ]; then
		chroma_src="chroma-sp"
	fi
fi
if [ x${primme}x != xx ]; then
	primme_src="primme"
fi
if [ x${magma}x != xx ]; then
	magma_src="magma"
fi
if [ x${cmake}x != xx ]; then
	cmake_src="cmake"
fi
if [ x${llvm}x != xx ]; then
	llvm_src="llvm-13"
fi
if [ x${cub}x != xx ]; then
	cub_src="cub"
fi
if [ x${prim}x != xx ]; then
	prim_src="rocPRIM"
fi
if [ x${thrust}x != xx ]; then
	[ $use_arch == cuda ] && thrust_src="thrust"
	[ $use_arch == hip ] && thrust_src="rocThrust"
fi
if [ x${openblas}x != xx ]; then
	openblas_src="openblas"
fi
if [ x${eigen}x != xx ]; then
	eigen_src="eigen"
fi
if [ x${superbblas}x != xx ]; then
	superbblas_src="superbblas"
	[ $use_superb_next == yes ] && superbblas_src="superbblas-sp"
fi
if [ x${adat}x != xx ]; then
	adat_src="adat"
	[ $use_pdf == yes ] && adat_src="adat-pdf"
fi
if [ x${colorvec}x != xx ]; then
	colorvec_src="colorvec"
	[ $use_pdf == yes ] && colorvec_src="colorvec-pdf"
fi
if [ x${tensor}x != xx ]; then
	tensor_src="tensor"
fi
if [ x${hadron}x != xx ]; then
	hadron_src="hadron"
fi
if [ x${harom}x != xx ]; then
	harom_src="harom"
fi
if [ x${redstar}x != xx ]; then
	redstar_src="redstar"
	[ $use_pdf == yes ] && redstar_src="redstar-pdf"
fi
if [ x${laplace_eigs}x != xx ]; then
	laplace_eigs_src="laplace_eigs"
fi
if [ x${gmp}x != xx ]; then
	gmp_src="gmp"
fi
if [ x${libxml2}x != xx ]; then
	libxml2_src="libxml2"
fi
if [ x${boost}x != xx ]; then
	boost_src="boost"
fi
if [ x${gcc}x != xx ]; then
	gcc_src="gcc"
	mpfr_src="mpfr"
	isl_src="isl"
	mpc_src="mpc"
fi
if [ x${openmpi}x != xx ]; then
	openmpi_src="openmpi"
fi
if [ x${ucx}x != xx ]; then
	ucx_src="ucx"
fi
if [ x${mvapich2}x != xx ]; then
	mvapich2_src="mvapich2"
fi



cat << EOF | while read act proj
$cmake        $cmake_src
$llvm         $llvm_src
$cub          $cub_src
$prim         $prim_src
$thrust       $thrust_src
$openblas     $openblas_src
$eigen        $eigen_src
$primme       $primme_src
$magma        $magma_src
$qmp          $qmp_src
$qdp          $qdp_src
$qphix        $qphix_src
$mgproto      $mgproto_src
$superbblas   $superbblas_src
$mugiq        $mugiq_src
$quda         $quda_src
$cpm          $cpm_src
$chroma       $chroma_src
$laplace_eigs $laplace_eigs_src
$adat         $adat_src
$colorvec     $colorvec_src
$tensor       $tensor_src
$hadron       $hadron_src
$harom        $harom_src
$redstar      $redstar_src
$gmp          $gmp_src
$libxml2      $libxml2_src
$gcc          $gcc_src
$mpfr         $mpfr_src
$isl          $isl_src
$mpc          $mpc_src
$boost        $boost_src
$openmpi      $openmpi_src
$ucx          $ucx_src
$mvapich2     $mvapich2_src
EOF
do
        cat << EOF | while read name repo branch
qdpxx                  https://github.com/usqcd-software/qdpxx         devel
qdp-jit                https://github.com/JeffersonLab/qdp-jit         devel
qdp-jit-no-concepts    https://github.com/eromero-vlc/qdp-jit          no-concepts
qmp                    https://github.com/usqcd-software/qmp           devel
chroma                 https://github.com/JeffersonLab/chroma          devel
chroma-sp              https://github.com/JeffersonLab/chroma          eloy/mgproton-progress-blocking
chroma-fs-sp           https://github.com/twLQCD/chroma.git            travis/mgproton-progress-blocking-fs
chroma                 https://github.com/JeffersonLab/chroma          devel
qphix                  https://github.com/JeffersonLab/qphix           devel
mgproto                https://github.com/JeffersonLab/mg_proto        devel
mgproto2               https://github.com/twLQCD/mg_proto.git          reuse_prolong
harom                  https://github.com/JeffersonLab/harom           devel
hadron                 https://github.com/JeffersonLab/hadron          devel
tensor                 https://github.com/JeffersonLab/tensor          master
redstar                https://github.com/JeffersonLab/redstar         devel
redstar2               https://github.com/JeffersonLab/redstar         eloy/hadron-node-lib
redstar-pdf            https://github.com/JeffersonLab/redstar         devel-pdf
adat                   https://github.com/JeffersonLab/adat            devel
adat-pdf               https://github.com/JeffersonLab/adat            devel-pdf
colorvec               https://github.com/JeffersonLab/colorvec        devel
colorvec-pdf           https://github.com/JeffersonLab/colorvec        devel-pdf
colorvec2              https://github.com/JeffersonLab/colorvec        eloy/hadron-node-lib
laplace_eigs           https://github.com/JeffersonLab/laplace_eigs    primme3
primme                 https://github.com/primme/primme                eloy/primme-3.3
magma                  http://icl.utk.edu/projectsfiles/magma/downloads/magma-2.7.1.tar.gz
superbblas             https://github.com/eromero-vlc/superbblas       master
superbblas-sp          https://github.com/eromero-vlc/superbblas       eloy/dense
quda                   https://github.com/lattice/quda                 develop
mugiq                  https://github.com/eromero-vlc/mugiq            master
#mugiq                  https://github.com/ckallidonis/mugiq            master
quda-mugiq             https://github.com/ckallidonis/quda             CK-MGDeflate
eigen                  https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.tar.bz2
cmake                  https://github.com/Kitware/CMake/releases/download/v3.24.2/cmake-3.24.2.tar.gz 
llvm-11                https://github.com/llvm/llvm-project/releases/download/llvmorg-11.1.0/llvm-11.1.0.src.tar.xz
llvm-13                https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.1/llvm-13.0.1.src.tar.xz
cub                    https://github.com/NVIDIA/cub/archive/refs/tags/1.17.2.tar.gz
thrust                 https://github.com/NVIDIA/thrust/archive/refs/tags/1.17.2.tar.gz
rocThrust              https://github.com/ROCmSoftwarePlatform/rocThrust/archive/refs/tags/rocm-5.4.3.tar.gz
rocPRIM                https://github.com/ROCmSoftwarePlatform/rocPRIM/archive/refs/tags/rocm-5.4.3.tar.gz
openblas               https://github.com/xianyi/OpenBLAS/releases/download/v0.3.23/OpenBLAS-0.3.23.tar.gz
cpm                    https://github.com/cpm-cmake/CPM.cmake/archive/refs/tags/v0.32.1.tar.gz
gmp                    https://gmplib.org/download/gmp/gmp-6.2.1.tar.xz
libxml2                https://download.gnome.org/sources/libxml2/2.10/libxml2-2.10.2.tar.xz
mpfr                   https://www.mpfr.org/mpfr-current/mpfr-4.1.0.tar.xz
gcc                    https://mirrors.concertpass.com/gcc/releases/gcc-10.1.0/gcc-10.1.0.tar.xz
isl                    https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.24.tar.bz2
mpc                    https://ftp.gnu.org/gnu/mpc/mpc-1.2.1.tar.gz
boost                  https://boostorg.jfrog.io/artifactory/main/release/1.80.0/source/boost_1_80_0.tar.bz2
ucx                    https://github.com/openucx/ucx/releases/download/v1.13.1/ucx-1.13.1.tar.gz
openmpi                https://download.open-mpi.org/release/open-mpi/v4.1/openmpi-4.1.4.tar.bz2
openmpi5               https://download.open-mpi.org/release/open-mpi/v5.0/openmpi-5.0.0rc9.tar.gz
mvapich2               https://mvapich.cse.ohio-state.edu/download/mvapich/mv2/mvapich2-2.3.7-1.tar.gz
EOF
	do
		[ x${proj}x != x${name}x ] && continue
		[ x${act}x == xupdatex -a -d $srcdir/$proj ] && continue
		if [ $do_cleaning == yes ]; then
			[ x${act}x == xclean -a -d $srcdir/$proj ] && rm -f $srcdir/$proj
			continue
		fi
		info "Downloading $proj"
		run rm -rf $srcdir/$proj $tmp/{d,d.zip,d.bz2,d.xz,d.gz}
		case $repo in
		*zip) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.zip && unzip $tmp/d.zip -d $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*bz2) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.bz2 && tar xjf $tmp/d.bz2 -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*gz) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.gz && tar xzf $tmp/d.gz -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*xz) mkdir $tmp/d && run wget --no-check-certificate -q "$repo" -O $tmp/d.xz && tar xJf $tmp/d.xz -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*git*) ( GIT_ASKPASS=w run git clone --recursive $repo -b $branch $srcdir/$proj ) || GIT_ASKPASS=w run git clone --recursive ${repo/https:\/\/github.com\//git@github.com:} -b $branch $srcdir/$proj;;
		*) echo "Don't know how to download $repo"; exit 1;;
		esac
		if [ $proj == cpm ] ; then ln -s $srcdir/$proj/cmake/CPM.cmake $srcdir/$proj/CPM_0.32.1.cmake ; fi
	done || exit 1
done || ( echo "Error happened while downloading source codes"  && false ) || exit 1

if [ $download_only == yes ]; then
	if [ $do_cleaning == yes ]; then
		echo "Combining --download-only with --clean actions is meaningless."
		exit 1
	fi
	exit 0
fi

# Installing packages

run mkdir -p $builddir
run mkdir -p $installdir
builddir="`realpath $builddir`"
installdir="`realpath $installdir`"
info "Build directory: $builddir"
info "Install directory: $installdir"
if [ x${do_export_env}x != xx ]; then
	info "Exporting environment in ${do_export_env}"
	rm -f $do_export_env
fi

if [ x${gcc}x != xx ]; then
	gcc_install="gcc"
	sdir="${srcdir}/${gcc_src}"
	bdir="${builddir}/${gcc_install}"
	idir="${installdir}/${gcc_install}"
	info "Doing ${gcc} GCC; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${gcc} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${gcc} == install -o ! -d ${idir} ]; then
		[ -e ${sdir}/mpfr ] || ln -s ${srcdir}/${mpfr_src} ${sdir}/mpfr
		[ -e ${sdir}/isl ] || ln -s ${srcdir}/${isl_src} ${sdir}/isl
		[ -e ${sdir}/mpc ] || ln -s ${srcdir}/${mpc_src} ${sdir}/mpc
		[ x${gmp}x != xx -a -f ${sdir}/gmp ] || ln -s ${srcdir}/${gmp_src} ${sdir}/gmp
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --disable-bootstrap --disable-multilib --enable-languages="c,c++,fortran" CC=gcc CXX=g++ CFLAGS= CXXFLAGS=
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	libexec_gcc=`realpath $idir/libexec/gcc/*/10.1.0`
	libplugin_gcc=`realpath $idir/lib/gcc/*/10.1.0/plugin`
	export LD_LIBRARY_PATH=$idir/lib:$idir/lib64:$libexec_gcc:$LD_LIBRARY_PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For gcc
export LD_LIBRARY_PATH="$idir/lib:$idir/lib64:$libexec_gcc:\$LD_LIBRARY_PATH"
export PATH="$idir/bin:\$PATH"
EOF
	fi
fi


if [ x${ucx}x != xx ]; then
	ucx_install="ucx"
	sdir="${srcdir}/${ucx_src}"
	bdir="${builddir}/${ucx_install}"
	idir="${installdir}/${ucx_install}"
	info "Doing ${ucx} ucx; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${ucx} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${ucx} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		case $use_opt in
		debug) ucx_extra="--enable-debug --enable-logging --enable-assertions --enable-params-check --disable-optimizations" ;;
		opt) ucx_extra="--disable-debug --disable-logging --disable-assertions --disable-params-check --enable-optimizations" ;;
		esac
		case $use_arch in
		cpu) ;;
		cuda) ucx_extra+=" --with-cuda=$CUDADIR" ;;
		hip) ucx_extra+="" ;;
		esac
		CFLAGS= CXXFLAGS= LDFLAGS= LIBS= run ${sdir}/configure --prefix=${idir} --without-java --enable-cma --with-verbs --without-xpmem --disable-doxygen-doc $ucx_extra
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For ucx
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
	fi
fi

if [ x${openmpi}x != xx ]; then
	openmpi_install="openmpi"
	sdir="${srcdir}/${openmpi_src}"
	bdir="${builddir}/${openmpi_install}"
	idir="${installdir}/${openmpi_install}"
	info "Doing ${openmpi} openmpi; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${openmpi} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${openmpi} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		case $use_opt in
		debug) openmpi_extra="--enable-debug" ;;
		opt) openmpi_extra="--disable-debug" ;;
		esac
		case $use_arch in
		cpu) ;;
		cuda)
			libcuda_path="`find $CUDADIR -name libcuda.so | head -1`"
			inccudart_path="`find $CUDADIR -name cuda_runtime_api.h | head -1`"
			libcudart_path="`find $CUDADIR -name libcudart.so | head -1`"
			openmpi_extra+=" --with-cuda=$CUDADIR --with-cuda-libdir=`dirname $libcuda_path` --enable-mca-dso=btl-smcuda,rcache-rgpusm,rcache-gpusm,accelerator-cuda CPPFLAGS=-I`dirname $inccudart_path` LDFLAGS=-L`dirname $libcudart_path`" ;;
		hip) openmpi_extra+="" ;;
		esac
		CFLAGS= CXXFLAGS= LDFLAGS= LIBS= run ${sdir}/configure --prefix=${idir} --with-ucx=${installdir}/${ucx_install} --enable-mca-no-build=btl-uct --disable-oshmem $openmpi_extra
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	[ x${CC}x != xx ] && export OMPI_CC=$CC
	[ x${CXX}x != xx ] && export OMPI_CXX=$CXX
	[ x${FC}x != xx ] && export OMPI_FC=$FC
	export CC=mpicc
	export CXX=mpicxx
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For openmpi
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
		[ x${OMPI_CC}x != xx ] && echo export OMPI_CC=$OMPI_CC >> $do_export_env
		[ x${OMPI_CXX}x != xx ] && echo export OMPI_CXX=$OMPI_CXX >> $do_export_env
		[ x${OMPI_FC}x != xx ] && echo export OMPI_FC=$OMPI_FC >> $do_export_env
	fi
fi

if [ x${mvapich2}x != xx ]; then
	mvapich2_install="mvapich2"
	sdir="${srcdir}/${mvapich2_src}"
	bdir="${builddir}/${mvapich2_install}"
	idir="${installdir}/${mvapich2_install}"
	info "Doing ${mvapich2} openmpi; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mvapich2} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mvapich2} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		case $use_arch in
		cpu) mvapich2_extra="" ;;
		cuda)
			mvapich2_extra="--with-cuda=$CUDADIR" ;;
		hip) mvapich2_extra="" ;;
		esac
		CFLAGS= CXXFLAGS= LDFLAGS= LIBS= run ${sdir}/configure --prefix=${idir} --enable-fast=all $mvapich2_extra
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	[ x${CC}x != xx ] && export MPICH_CC=$CC
	[ x${CXX}x != xx ] && export MPICH_CXX=$CXX
	[ x${FC}x != xx ] && export MPICH_FC=$FC
	export CC=mpicc
	export CXX=mpicxx
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For mvapich2
export PATH="$idir/bin:\$PATH"
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
EOF
		[ x${MPICH_CC}x != xx ] && echo export MPICH_CC=$MPICH_CC >> $do_export_env
		[ x${MPICH_CXX}x != xx ] && echo export MPICH_CXX=$MPICH_CXX >> $do_export_env
		[ x${MPICH_FC}x != xx ] && echo export MPICH_FC=$MPICH_FC >> $do_export_env
	fi
fi


if [ x${cmake}x != xx ]; then
	cmake_install="cmake"
	sdir="${srcdir}/${cmake_src}"
	bdir="${builddir}/${cmake_install}"
	idir="${installdir}/${cmake_install}"
	info "Doing ${cmake} cmake; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${cmake} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${cmake} == install -o ! -d ${idir} ]; then
		for i in 0 1; do
			run rm -rf $bdir $idir
			run mkdir -p $bdir
			pushd $bdir
			if [ $i = 0 ] ; then
			       	if cmake --version &> /dev/null; then
					run cmake -DCMAKE_USE_OPENSSL=OFF -DCMAKE_INSTALL_PREFIX=${idir} ${sdir}
					( run ${MYMAKE} -j $MAKE_JN install ) && popd && break
				else
					run $sdir/configure --prefix=$idir
					( run ${MYMAKE} -j $MAKE_JN install ) && popd && break
				fi
			else
				# On some machines, cmake fails to compile excepting with the system compilers
				(
					export CFLAGS=
					export CXXFLAGS=
					run $sdir/configure --prefix=$idir CC=/usr/bin/gcc CXX=/usr/bin/g++
					run ${MYMAKE} -j $MAKE_JN install
				)
			fi
			popd
		done
	fi
	export PATH=$idir/bin:$PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For cmake
export PATH="$idir/bin:\$PATH"
EOF
	fi
fi

if [ x${llvm}x != xx ]; then
	llvm_install="llvm"
	sdir="${srcdir}/${llvm_src}"
	bdir="${builddir}/${llvm_install}"
	idir="${installdir}/${llvm_install}"
	info "Doing ${llvm} LLVM; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${llvm} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${llvm} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run cmake \
		      -DLLVM_ENABLE_TERMINFO="OFF" \
		      -DCMAKE_BUILD_TYPE=Release \
		      -DCMAKE_INSTALL_PREFIX=${idir} \
		      -DLLVM_TARGETS_TO_BUILD="NVPTX;X86" \
		      -DLLVM_ENABLE_ZLIB="OFF" \
		      -DBUILD_SHARED_LIBS="OFF" \
		      -DLLVM_ENABLE_RTTI="ON"  \
		      $sdir
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
	if [ x${do_export_env}x != xx ]; then
		cat << EOF >> $do_export_env
# For llvm
export LD_LIBRARY_PATH="$idir/lib:\$LD_LIBRARY_PATH"
export PATH="$idir/bin:\$PATH"
EOF
	fi
fi

if [ x${cub}x != xx ]; then
	cub_install="cub"
	sdir="${srcdir}/${cub_src}"
	info "Doing ${cub} CUB; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${cub} == clean ] && rm -rf $sdir
	fi
fi

if [ x${prim}x != xx ]; then
	prim_install="prim"
	sdir="${srcdir}/${prim_src}"
	info "Doing ${prim} prim; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${prim} == clean ] && rm -rf $sdir
	fi
fi

if [ x${thrust}x != xx ]; then
	thrust_install="thrust"
	sdir="${srcdir}/${thrust_src}"
	info "Doing ${thrust} thrust; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${thrust} == clean ] && rm -rf $sdir
	fi
fi

if [ x${openblas}x != xx ]; then
	openblas_install="openblas"
	sdir="${srcdir}/${openblas_src}"
	bdir="${builddir}/${openblas_install}"
	idir="${installdir}/${openblas_install}"
	info "Doing ${openblas} OpenBLAS; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${openblas} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${openblas} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r $sdir $bdir
		pushd $bdir
		(
			# Setting CFLAGS avoid Openblas to set proper flags
			unset CFLAGS
			unset CXXFLAGS
			run ${MYMAKE} -j $MAKE_JN USE_OPENMP=1
			run ${MYMAKE} install PREFIX=${idir}
		)
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS+=" ${idir}/lib/libopenblas.a -lm -lpthread"
	LDFLAGS+=" -L${idir}/lib"
	[ `detect_fortran_compiler` == gcc ] && LIBS+=" -lgfortran"
	[ `detect_fortran_compiler` == nvc ] && LIBS+=" -lgfortran"
	[ `detect_fortran_compiler` == flang ] && LIBS+=" -lpgmath -lflang -lflangrti -lm"
fi

case $use_blas in
	mkl*) blas="Intel10_64lp_seq";;
	openblas*) blas="OpenBLAS"; [ x${openblas}x != xx ] && cmake_blas_extra=" -DLAPACK_LIBRARIES=${installdir}/${openblas_install}/lib/libopenblas.a -DBLAS_openblas_LIBRARY=${installdir}/${openblas_install}/lib/libopenblas.a";;
	atlas*) blas="ATLAS";;
esac
CMAKE_EXTRA_FLAGS="-DBLA_STATIC=ON -DBLA_VENDOR=$blas $cmake_blas_extra $CMAKE_EXTRA_FLAGS" 

if [ x${boost}x != xx ]; then
	boost_install="boost"
	sdir="${srcdir}/${boost_src}"
	info "Doing ${boost} boost; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${boost} == clean ] && rm -rf $sdir
	fi
fi

if [ x${tensor}x != xx ]; then
	tensor_install="tensor"
	sdir="${srcdir}/${tensor_src}"
	bdir="${builddir}/${tensor_install}"
	idir="${installdir}/${tensor_install}"
	info "Doing ${tensor} tensor; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${tensor} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${tensor} == install -o ! -d ${idir} ]; then
		( cd $sdir && run bash autogen.sh )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		case "`detect_compiler`" in
		icc) run ${sdir}/configure --prefix=${idir} --without-arpack $tensor_extra_opts CC=icc CXX=icpc ;;
		*)   run ${sdir}/configure --prefix=${idir} --without-arpack $tensor_extra_opts ;;
		esac
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${hadron}x != xx ]; then
	hadron_install="hadron"
	sdir="${srcdir}/${hadron_src}"
	bdir="${builddir}/${hadron_install}"
	idir="${installdir}/${hadron_install}"
	info "Doing ${hadron} hadron; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${hadron} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${hadron} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-tensor=${installdir}/${tensor_install}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${gmp}x != xx ]; then
	gmp_install="${gmp_src}"
	sdir="${srcdir}/${gmp_src}"
	bdir="${builddir}/${gmp_install}"
	idir="${installdir}/${gmp_install}"
	info "Doing ${gmp} gmp; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${gmp} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${gmp} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --enable-cxx --disable-shared --with-pic
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS+=" -L${idir}/lib -lgmpxx -lgmp"
fi

if [ x${libxml2}x != xx ]; then
	libxml2_install="${libxml2_src}"
	sdir="${srcdir}/${libxml2_src}"
	bdir="${builddir}/${libxml2_install}"
	idir="${installdir}/${libxml2_install}"
	info "Doing ${libxml2} libxml2; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${libxml2} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${libxml2} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --disable-shared --enable-static --with-pic --without-python --without-http --without-html --without-lzma --without-zlib
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS+=" -L${idir}/lib -lxml2"
	LD_LIBRARY_PATH+=":${idir}"
	PKG_CONFIG_PATH+=":${idir}/lib/pkgconfig"
	PATH+=":${idir}/bin"
fi


if [ x${adat}x != xx ]; then
	adat_install="${adat_src}"
	sdir="${srcdir}/${adat_src}"
	bdir="${builddir}/${adat_install}"
	idir="${installdir}/${adat_install}"
	info "Doing ${adat} adat; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${adat} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${adat} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${colorvec}x != xx ]; then
	colorvec_install="${colorvec_src}"
	sdir="${srcdir}/${colorvec_src}"
	bdir="${builddir}/${colorvec_install}"
	idir="${installdir}/${colorvec_install}"
	info "Doing ${colorvec} colorvec; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${colorvec} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${colorvec} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-adat=${installdir}/${adat_install}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qmp}x != xx ]; then
	qmp_install="qmp"
	use_qmp_cmake="nop"
	[ ${qdp_src} == qdp-jit -o x${quda}x != xx ] && use_qmp_cmake="yes"
	[ ${use_qmp_cmake} == yes ] && qmp_install="qmp-cmake"
	sdir="${srcdir}/${qmp_src}"
	bdir="${builddir}/${qmp_install}"
	idir="${installdir}/${qmp_install}"
	info "Doing ${qmp} qmp; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${qmp} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${qmp} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		if [ ${qmp_install} == qmp ]; then
			( cd $sdir && run autoreconf -f )
			run ${sdir}/configure --prefix=${idir} --with-qmp-comms-type=MPI --with-qmp-comms-cflags="" --with-qmp-comms-ldflags="" --with-qmp-comms-libs=""
		else
			run cmake \
				-DCMAKE_INSTALL_PREFIX=${idir} \
				-DBUILD_TESTING=OFF \
				-DQMP_MPI=ON \
				-DQMP_TIMING=OFF \
				${CMAKE_EXTRA_FLAGS} \
				${sdir}
		fi
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qdp}x != xx ]; then
	qdp_prec="double"
	[ ${use_float} == yes ] && qdp_prec="single"
	sdir="${srcdir}/${qdp_src}"
	if [ $do_cleaning == nop -a $use_arch == cuda -a $qdp_src == qdp-jit ]; then
		run rm -rf ${tmp}/h
		run mkdir -p ${tmp}/h
		run cp ${CUDADIR}/nvvm/libdevice/libdevice*bc ${tmp}/h/libdevice.bc
		( cd $sdir && run bash ./pack_libdevice.sh ${tmp}/h )
	fi
	qdp_extra=""
	if [ $qdp_src == qdp-jit ]; then
		case $use_arch in
		cuda)
			qdp_extra+=" -DQDP_ENABLE_BACKEND=CUDA -DQDP_ENABLE_THRUST_ALIGNMENT=ON"
			;;
		hip)
			qdp_extra+=" -DQDP_ENABLE_BACKEND=ROCM -DGPU_TARGETS=${AMDGPU_TARGETS}"
			;;
		esac
	fi
	if [ $qdp_src == qdp-jit ]; then
        	llvm_ver="`llvm-config --version`"
        	case $llvm_ver in
		14*) qdp_extra+=" -DQDP_ENABLE_LLVM14=ON" ;;
		15*) qdp_extra+=" -DQDP_ENABLE_LLVM15=ON" ;;
		16*) qdp_extra+=" -DQDP_ENABLE_LLVM16=ON" ;;
        	esac
        	rocm_ver="`hipconfig --version`"
        	case $rocm_ver in
		5.1*) qdp_extra+=" -DQDP_ROCM5FIX=ON -DQDP_ROCM_PRE=ON" ;;
		5.0*|4.*) qdp_extra+=" -DQDP_ROCM_PRE=ON" ;;
        	esac
	fi
	use_qdp_cmake="nop"
	[ ${qdp_src} == qdp-jit -o x${quda}x != xx ] && use_qdp_cmake="yes"

	for qdp_nd in 3 4 ; do
		qdp_install="${qdp_src}-${qdp_prec}-nd${qdp_nd}"
		[ ${use_qdp_cmake} == yes ] && qdp_install+="-cmake"
		bdir="${builddir}/${qdp_install}"
		idir="${installdir}/${qdp_install}"
		info "Doing ${qdp} QDP nd=$qdp_nd; source=$sdir build=$bdir install=$idir"
		if [ $do_cleaning == yes ]; then
			[ ${qdp} == clean ] && rm -rf $sdir $bdir $idir
		elif [ ${qdp} == install -o ! -d ${idir} ]; then
			run rm -rf $bdir $idir
			run mkdir -p $bdir
			pushd $bdir
			if [ $qdp_src == qdpxx -a ${use_qdp_cmake} == nop ]; then
				[ $qdp_src == qdpxx ] && ( cd $sdir && run autoreconf -f )
				run ${sdir}/configure \
					--prefix=${idir} \
        				--enable-Nd=$qdp_nd \
				        --enable-parallel-arch=parscalar \
					--enable-precision=${qdp_prec} \
				        --enable-filedb \
					--disable-generics \
				        --enable-parallel-io \
				        --enable-alignment=64 \
					--with-qmp=${installdir}/${qmp_install} \
				        --enable-openmp
			else
				run cmake \
					-DCMAKE_INSTALL_PREFIX=${idir} \
					-DQDP_BUILD_EXAMPLES=OFF \
					-DQDP_PARALLEL_ARCH=parscalar \
					-DQDP_ND=$qdp_nd \
					-DQDP_PRECISION=${qdp_prec} \
					-DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP \
					$qdp_extra \
					${CMAKE_EXTRA_FLAGS} \
					${sdir}
			fi
			run ${MYMAKE} install -j $MAKE_JN
			popd
		fi
	done
	qdp_install="${qdp_src}-${qdp_prec}-nd4"
	[ ${use_qdp_cmake} == yes ] && qdp_install+="-cmake"
	qdp3d_install="${qdp_src}-${qdp_prec}-nd3"
	[ ${use_qdp_cmake} == yes ] && qdp3d_install+="-cmake"
fi

if [ x${quda}x != xx ]; then
	quda_install="${quda_src}-${qdp_install}"
	sdir="${srcdir}/${quda_src}"
	bdir="${builddir}/${quda_install}"
	idir="${installdir}/${quda_install}"
	info "Doing ${quda} QUDA; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${quda} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${quda} == install -o ! -d ${idir} ]; then
		build_type="RELEASE"
		[ $use_opt == debug ] && build_type="DEBUG"
		if [ $use_arch != hip ]; then
			quda_extra_args="\
				-DQUDA_TARGET_TYPE=CUDA \
				-DQUDA_GPU_ARCH=$SM \
				-DCMAKE_CUDA_ARCHITECTURES=${SM#sm_} \
				-DCMAKE_C_COMPILER=${CC} \
				-DCMAKE_CXX_COMPILER=${CXX} \
				-DCMAKE_LINKER=${CXX} \
				-DCMAKE_EXE_LINKER_FLAGS="-L${CUDADIR}" \
			"
		else
			quda_extra_args="\
				-DQUDA_TARGET_TYPE=HIP \
				-DGPU_TARGETS=$AMDGPU_TARGETS \
				-DAMDGPU_TARGETS=$AMDGPU_TARGETS \
				-DQUDA_GPU_ARCH=$AMDGPU_TARGETS \
				-DMPI_C_COMPILER=${CC} \
				-DMPI_CXX_COMPILER=${CXX}"
			# Avoid compiling issue in QUDA
			quda_extra_args+=" -DQUDA_OPENMP=OFF"
		fi
		quda_extra_args+=" -DQUDA_QMP=ON -DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP"
		[ $qdp_src == qdp-jit ] && quda_extra_args+=" -DQUDA_QDPJIT=ON -DQUDA_INTERFACE_QDPJIT=ON"
		quda_extra_args+=" -DQUDA_INTERFACE_QDP=ON -DQDPXX_DIR=${installdir}/${qdp_install}/lib/cmake/QDPXX"

		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		CPM_SOURCE_CACHE=$srcdir CXXFLAGS="${CXXFLAGS//-std=c++??/}" run cmake  \
			-DQUDA_DIRAC_CLOVER=ON \
			-DQUDA_DIRAC_DOMAIN_WALL=OFF \
			-DQUDA_DIRAC_NDEG_TWISTED_MASS=OFF \
			-DQUDA_DIRAC_STAGGERED=OFF \
			-DQUDA_DIRAC_TWISTED_MASS=OFF \
			-DQUDA_DIRAC_TWISTED_CLOVER=OFF \
			-DQUDA_DIRAC_WILSON=ON \
			-DQUDA_DYNAMIC_CLOVER=OFF \
			-DQUDA_FORCE_GAUGE=OFF \
			-DQUDA_FORCE_HISQ=OFF \
			-DQUDA_GAUGE_ALG=OFF \
			-DQUDA_GAUGE_TOOLS=OFF \
			-DQUDA_INTERFACE_MILC=OFF \
			-DQUDA_INTERFACE_CPS=OFF \
			-DQUDA_INTERFACE_TIFR=OFF \
			-DQUDA_MAGMA=OFF	\
			-DQUDA_MULTIGRID=ON \
			-DQUDA_MAX_MULTI_BLAS_N=9 \
			-DQUDA_DOWNLOAD_EIGEN=NO \
			-DEIGEN_INCLUDE_DIR=${srcdir}/${eigen_src} \
			-DCMAKE_INSTALL_PREFIX=${idir} \
			-DCMAKE_BUILD_TYPE=$build_type \
			-DQUDA_BUILD_SHAREDLIB=NO \
			-DQUDA_BUILD_ALL_TESTS=OFF \
			$quda_extra_args \
			${CMAKE_EXTRA_FLAGS} \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN

		# Avoid QUDA injecting HIP language into anything linked with it
		[ $use_arch == hip ] && sed -i 's/;HIP//' ${idir}/lib/cmake/QUDA/QUDATargets-release.cmake
		popd
	fi
fi

if [ x${mugiq}x != xx ]; then
	mugiq_install="${mugiq_src}-${quda_install}"
	sdir="${srcdir}/${mugiq_src}"
	bdir="${builddir}/${mugiq_install}"
	idir="${installdir}/${mugiq_install}"
	info "Doing ${mugiq} mugiq; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mugiq} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mugiq} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		cmake  \
			-DMUGIQ_GPU_ARCH=$SM \
			-DMUGIQ_QUDA=ON \
			-DMUGIQ_QUDA_SOURCE=${srcdir}/${quda_src} \
			-DMUGIQ_QUDA_HOME=${installdir}/${quda_install} \
			-DMUGIQ_MAGMA=OFF       \
			-DCMAKE_COMMS_TYPE=QMP \
			-DMUGIQ_QMP_HOME=${installdir}/${qmp_install} \
			-DMUGIQ_QIO=ON \
			-DMUGIQ_QIO_HOME=${installdir}/${qdp_install} \
			-DMUGIQ_LIME_HOME=${installdir}/${qdp_install} \
			-DCMAKE_INSTALL_PREFIX=${idir} \
			-DCMAKE_BUILD_TYPE=DEVEL \
			-DCMAKE_CXX_COMPILER=${CXX} \
			-DCMAKE_C_COMPILER=${CC} \
			-DCMAKE_LINKER=${CXX} \
			-DCMAKE_EXE_LINKER_FLAGS="-L${CUDADIR}" \
			-DMUGIQ_BUILD_ALL_TESTS=OFF \
			${CMAKE_EXTRA_FLAGS} \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qphix}x != xx ]; then
	case ${use_march} in
	avx512|knl)     qphix_isa="avx512";;
	avx2|zen2|zen3) qphix_isa="avx2";;
	avx)            qphix_isa="avx" ;;
	*)
		info "Unsupported architecture for Qphix: $use_march"
		exit 1
		;;
	esac
	qphix_install="${qphix_src}-${qdp_install}-${qphix_isa}"
	sdir="${srcdir}/${qphix_src}"
	bdir="${builddir}/${qphix_install}"
	idir="${installdir}/${qphix_install}"
	info "Doing ${qphix} QPhiX; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${qphix} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${qphix} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run cmake -Disa=${qphix_isa} \
		      -Dhost_cxx=${CXX} \
		      -Dhost_cxxflags="" \
		      -Drecursive_jN=${MAKE_JN} \
		      -DCMAKE_INSTALL_PREFIX=${idir} \
		      -DQDPXX_DIR=${installdir}/${qdp_install} \
		      -Dclover=TRUE \
		      -Dtm_clover=TRUE \
		      -Dcean=FALSE \
		      -Dqdpalloc=FALSE \
		      -Dqdpjit=FALSE \
		      -Dtesting=OFF \
		      -DPYTHON_EXECUTABLE="$( which python3 )" \
		      -DPYTHON_INCLUDE_DIR=/usr/include \
		      -DPYTHON_LIBRARY=/usr/lib \
		      ${CMAKE_EXTRA_FLAGS} \
		      ${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${magma}x != xx ]; then
	magma_install="magma-${use_arch}"
	sdir="${srcdir}/${magma_src}"
	bdir="${builddir}/${magma_install}"
	idir="${installdir}/${magma_install}"
	info "Doing ${magma} MAGMA; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${magma} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${magma} == install -o ! -d ${idir} ]; then
		if [ $use_arch == cpu ]; then
			echo MAGMA has to be compile for CUDA or HIP
			exit 1
		fi

		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		CXXFLAGS="${CXXFLAGS//-std=c++??/}" run cmake -DCMAKE_INSTALL_PREFIX=${idir} \
			-DBUILD_SHARED_LIBS=OFF -DGPU_TARGET=$SM \
			-DUSE_FORTRAN=OFF \
			-DMAGMA_ENABLE_CUDA=ON \
			-DCMAKE_EXE_LINKER_FLAGS="$LIBS" -DLAPACK_LIBRARIES="m $LIBS"\
			${CMAKE_EXTRA_FLAGS} \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
	CFLAGS+=" -I${installdir}/${magma_install}/include"
	CXXFLAGS+=" -I${installdir}/${magma_install}/include"
	LIBS="${installdir}/${magma_install}/lib/libmagma.a $LIBS"
fi


if [ x${primme}x != xx ]; then
	primme_install="primme-${use_arch}"
	[ $use_arch == hip ] && primme_install="primme-cpu"
	sdir="${srcdir}/${primme_src}"
	bdir="${builddir}/${primme_install}"
	idir="${installdir}/${primme_install}"
	info "Doing ${primme} PRIMME; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${primme} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${primme} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r ${srcdir}/${primme_src} $bdir
		if [ $use_arch == cpu -o $use_arch == hip ]; then
			run $MYMAKE -C ${bdir} lib install PREFIX=${idir} -j $MAKE_JN CFLAGS="$CFLAGS -fPIC"
		elif [ $use_arch == cuda ]; then
			run $MYMAKE -C ${bdir} lib install PREFIX=${idir} -j $MAKE_JN CFLAGS="$CFLAGS -fPIC" CUDADIR="$CUDADIR" MAGMADIR="${installdir}/${magma_install}"
		fi
		run rm ${idir}/lib/libprimme.so*
		run cp ${bdir}/lib/libprimme.a ${idir}/lib
	fi
	CFLAGS+=" -I${installdir}/${primme_install}/include"
	CXXFLAGS+=" -I${installdir}/${primme_install}/include"
	LIBS="${installdir}/${primme_install}/lib/libprimme.a $LIBS"
fi

if [ x${superbblas}x != xx ]; then
	superbblas_install="superbblas-cpu"
	[ $use_arch == cuda ] && superbblas_install="superbblas-cuda"
	[ $use_arch == hip ] && superbblas_install="superbblas-hip"
	[ $use_superb_next == yes ] && superbblas_install+="-next"
	sdir="${srcdir}/${superbblas_src}"
	bdir="${builddir}/${superbblas_install}"
	idir="${installdir}/${superbblas_install}"
	info "Doing ${superbblas} Superbblas; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${superbblas} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${superbblas} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r ${srcdir}/${superbblas_src}/ $bdir
		make_action="install_cpu"
		if [ $use_arch == cuda ]; then
			make_action="install_cuda"
			[ x${thrust}x != xx ] && sb_nvcc_extra="-I${srcdir}/${cub_src} -I${srcdir}/${thrust_src}"
			[ $use_next == nop ] && sb_nvcc_extra+=" -std=c++14"
			[ $use_opt == debug ] && sb_nvcc_extra+=" -G"
			[ $use_opt == opt ] && sb_nvcc_extra+=" -O3"
			export NVCCFLAGS="-x cu -arch=$SM $NVCCFLAGS $sb_nvcc_extra"
		elif [ $use_arch == hip ]; then
			make_action="install_hip"
			hip_arch_flags="$( for arch in ${AMDGPU_TARGETS//;/ }; do echo -n "--offload-arch=$arch "; done )"
			export HIPFLAGS="`$HIPCONFIG -C` -I`$HIPCONFIG -R`/hipblas/include -I`$HIPCONFIG -R`/hipsparse/include -I`$HIPCONFIG -R`/hipsolver/include $hip_arch_flags"
		fi
		[ $use_blas == mkl-system ] && sb_cxx_extra+=" -DSUPERBBLAS_USE_MKL"
		CXXFLAGS_sb="${CXXFLAGS} $sb_cxx_extra"
		[ $use_arch != cpu -a $use_next == nop ] && CXXFLAGS_sb="${CXXFLAGS//-std=c++??/} -std=c++14"
		run $MYMAKE -C ${bdir} -j $MAKE_JN $make_action BUILDDIR=${idir} CXXFLAGS="$CXXFLAGS_sb"
	fi
	# Add flags to compile and link with HIP runtime and to link with clang openmp
	[ $use_arch == hip ] && CXXFLAGS+=" `$HIPCONFIG -C` -I`$HIPCONFIG -R`/include"
	[ $use_arch == hip ] && LIBS+=" -L`$HIPCONFIG -R`/lib -lhipsolver -lhipsparse -lhipblas -lamdhip64 -L`$HIPCONFIG -l`/../lib -lomp"
fi

if [ x${mgproto}x != xx ]; then
	mgproto_install="${mgproto_src}-${qphix_install}"
	sdir="${srcdir}/${mgproto_src}"
	bdir="${builddir}/${mgproto_install}"
	idir="${installdir}/${mgproto_install}"
	info "Doing ${mgproto} mgproto; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mgproto} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mgproto} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		mgproto_extra="-DMG_USE_PRIMME=ON -DPRIMME_HOME=${installdir}/${primme_install}"
		cmake \
		    -DMG_USE_KOKKOS=FALSE \
		    -DMG_USE_QPHIX=TRUE \
		    -DQPHIX_DIR=${installdir}/${qphix_install} \
		    -DMG_QPHIX_COMPRESS12=TRUE \
		    -DMG_QPHIX_SOALEN=4 \
		    -DMG_USE_AVX512=FALSE \
		    -DEigen3_DIR=${srcdir}/${eigen_src} \
		    -DKOKKOS_ENABLE_CUDA=FALSE \
		    -DCMAKE_INSTALL_PREFIX=${idir} \
		    -DQDPXX_DIR=${installdir}/${qdp_install} \
		    -DBUILD_TESTING=OFF \
		    -DMG_DEFAULT_LOGLEVEL=DEBUG \
		    -DMG_KOKKOS_USE_NEIGHBOR_TABLE=FALSE \
		     $mgproto_extra \
		     ${CMAKE_EXTRA_FLAGS} \
		     ${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${chroma}x != xx ]; then
	if [ $use_mg == nop ]; then
		chroma_install="${chroma_src}-${qdp_install}"
	elif [ $use_arch == cpu ]; then
		chroma_install="${chroma_src}-${mgproto_install}"
	else
		chroma_install="${chroma_src}-${quda_install}"
	fi
	[ x${superbblas}x != xx ] && chroma_install+="-${superbblas_install}"
	sdir="${srcdir}/${chroma_src}"
	bdir="${builddir}/${chroma_install}"
	idir="${installdir}/${chroma_install}"
	info "Doing ${chroma} chroma; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${chroma} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${chroma} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		if [ ${use_qdp_cmake} == nop ]; then
			( cd $sdir && run autoreconf -f )
			if [ x${mgproto}x != xx ]; then
				chroma_extra="\
			        	--with-qphix-solver=${installdir}/${qphix_install} \
			        	--enable-qphix-solver-arch=${qphix_isa} \
			        	--enable-qphix-solver-soalen=4 \
			        	--disable-qphix-solver-compress12 \
			        	--enable-qphix-solver-inner-type=f \
			        	--enable-qphix-solver-inner-soalen=8 \
			        	--with-mg-proto=${installdir}/${mgproto_install}"
			fi
			[ ${use_arch} == cuda ] && chroma_extra+=" --with-cuda=${CUDADIR}"
			[ x${primme}x != xx ] && chroma_extra+=" --with-primme=${installdir}/${primme_install}"
			[ x${superbblas}x != xx ] && chroma_extra+=" --with-superbblas=${installdir}/${superbblas_install}"
			[ $use_next == yes -a x${boost}x != xx ] && chroma_extra+=" --with-boost=${srcdir}/${boost_install}"
			run ${sdir}/configure \
				--prefix=${idir} \
				--with-qdp=${installdir}/${qdp_install} \
				--with-qmp=${installdir}/${qmp_install} \
			        --enable-static-packed-gauge \
			        --enable-fused-clover-deriv-loops \
				--enable-lapack=lapack --enable-opt-eigcg \
				$chroma_extra CXXFLAGS="$CXXFLAGS $sb_cxx_extra"
		else
			chroma_extra=""
			[ $use_arch != cpu -a $use_mg == yes ] && chroma_extra="\
				-DChroma_ENABLE_QUDA=ON \
				-DQUDA_DIR=${installdir}/${quda_install}/lib/cmake/QUDA \
				"
			[ $qdp_src == qdp-jit ] && chroma_extra+=" -DChroma_ENABLE_JIT_CLOVER=ON"
			[ x${magma}x != xx ] && chroma_extra+=" -DChroma_ENABLE_MAGMA=ON -DMAGMA_DIR=${installdir}/${magma_install}"
			[ x${primme}x != xx ] && chroma_extra+=" -DChroma_ENABLE_PRIMME=ON -DPRIMME_DIR=${installdir}/${primme_install}"
			[ x${superbblas}x != xx ] && chroma_extra+=" -DChroma_ENABLE_SUPERBBLAS=ON -DSUPERBBLAS_DIR=${installdir}/${superbblas_install}"
			[ ${use_next} == yes -a x${boost}x != xx ] && chroma_extra+=" -DChroma_ENABLE_BOOST=ON -DBOOST_DIR=${srcdir}/${boost_install}"
			[ ${use_arch} == hip ] && chroma_extra+=" -DCMAKE_HIP_COMPILER=$CXX -DCMAKE_HIP_COMPILER_FORCED=ON"
			[ ${use_arch} == cuda -a ${qdp_src} == qdp ] && chroma_extra+=" -DChroma_ENABLE_CUDA=ON"
			[ ${use_arch} == hip -a ${qdp_src} == qdp ] && chroma_extra+=" -DChroma_ENABLE_ROCM=ON"

			run cmake \
				-DCMAKE_INSTALL_PREFIX=${idir} \
				-DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS $LIBS" \
				-DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP \
				-DQDPXX_DIR=${installdir}/${qdp_install}/lib/cmake/QDPXX \
				-DBLAS_SUFFIX_LINK_FLAGS="$LIBS $chroma_extra_blas" \
				$chroma_extra \
				${CMAKE_EXTRA_FLAGS} \
				${sdir}
		fi
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${harom}x != xx ]; then
	harom_install="harom-${qdp3d_install}"
	sdir="${srcdir}/${harom_src}"
	bdir="${builddir}/${harom_install}"
	idir="${installdir}/${harom_install}"
	info "Doing ${harom} harom; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${harom} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${harom} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-qdp=${installdir}/${qdp3d_install} \
			--enable-experimental-baryon-blas-creation
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${redstar}x != xx ]; then
	redstar_install="${redstar_src}"
	sdir="${srcdir}/${redstar_src}"
	bdir="${builddir}/${redstar_install}"
	idir="${installdir}/${redstar_install}"
	info "Doing ${redstar} redstar; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${redstar} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${redstar} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-adat=${installdir}/${adat_install} --with-colorvec=${installdir}/${colorvec_install}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${laplace_eigs}x != xx ]; then
	laplace_eigs_install="laplace_eigs-${qdp3d_install}"
	sdir="${srcdir}/${laplace_eigs_src}"
	bdir="${builddir}/${laplace_eigs_install}"
	idir="${installdir}/${laplace_eigs_install}"
	info "Doing ${laplace_eigs} laplace_eigs; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${laplace_eigs} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${laplace_eigs} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p ${idir}
		run cp -r $sdir $bdir
		pushd $bdir
		run ${MYMAKE} ARCH="QMP" PRIMME_ENV=${installdir}/${primme_install} QDP_CONFIG_ND3_ENV=${installdir}/${qdp3d_install}/bin/qdp++-config QDP_CONFIG_ND4_ENV=${installdir}/${qdp_install}/bin/qdp++-config
		run cp laplace_eigs vecs_combine_4d vecs_combine_3d ${idir}
		popd
	fi
fi

# Everything went ok!
# Avoid removing the last installation by function finish
idir=""
