#!/bin/bash

## Ultimate script to install chroma ecosystem
##

read -r -d '' hlp_msg << 'EOF'
Script for installing chroma and redstar and related software.

chromaform [--source-dir=dir] [--build-dir=dir] [--install-dir=dir]                     \\
           [--float] [--cuda|--hip] [--mg] [--pdf] [--next]                             \\
           [--cmake=build|--cmake=system] [--llvm=build|--llvm=system]                  \\
           [--thrust=build|--thrust=system]                                             \\
           [--blas=openblas|--blas=openblas-system|--blas=atlas-system|--blas=mkl]      \\
           [-g|-O|-Onone] [--knl] [--avx512] [--autoflags=no] [--std=c++11|--std=c++14|--std=c++20] \\
           [--clean|--install|--update|--download-only] [cmake] [llvm] [cub] [thrust]   \\
           [openblas] [eigen] [qmp] [qdp] [superbblas] [primme] [mgproto] [qphix]       \\
           [chroma] [laplace_eigs] [adat] [colorvec] [tensor] [hadron] [redstar]        \\
           [CC=...] [CFLAGS=...] [CXX=...] [CXXFLAGS=...] [FC=...] [SM=...]

Examples:

# Install chroma with mg_proto/QPhiX
chromaform --mg chroma
# Install chroma with mg_proto/QPhiX with AVX512 support
chromaform --mg --avx512 chroma
# Install chroma with QUDA for arch=sm_70
chromaform --mg --jit chroma SM=sm_70
# Install redstar and harom
chromaform redstar harom

* Location options:
Each installed package will have an entry in the directories indicated
for keeping the source, the compilation, and the installation. 

--source-dir=<dir> 
   Directory where to put the sources; the default is \$PWD/src.
--build-dir=<dir>
   Directory where to build the packages; the default is \$PWD/build.
--install-dir=<dir>
   Directory where to install the packages; the default is \$PWD/install.

* Package flavor options:
Some packages have special optional features.

--float
   Install the single-precision version; the double precision version is installed
   by default. Used by QDP.
--cuda
   Install the CUDA/JIT version; the CPU version is installed by default. Used by QDP,
   superbblas, and chroma.
--hip
   Install the HIP/JIT version; the CPU version is installed by default. Used by QDP,
   superbblas, and chroma.
--mg
   Install multigrid extension of chroma; it isn't installed by default.
--pdf
   Install the devel-pdf branches of adat, colorvec and redstar; the devel branch is
   installed by default.
--next
   Install upcoming versions of some packages; the version in devel or master is
   installed by default. Used by:
   - QPhiX/mg_proto/chroma: multiple right-hand-side inversions and efficient CPU/GPU
     computation of disconnect diagrams, props and genprops with superbblas.
   - colorvec/redstar: smearing elementals on the fly.

* CMake, LLVM, BLAS:
   Some packages require CMake, LLVM, and BLAS, and this are the options to select
   which implementation to use.

--cmake=[build|system]
   Use the cmake in \$PATH if 'system' is given; otherwise, it builds a recent version.
   By default, it detects the cmake version available, and build cmake if it is not
   recent enough.

--llvm=[build|system]
   Use the LLVM indicated by llvm-config  in \$PATH if 'system' is given; otherwise, it
   builds a recent version. By default, it detects the LLVM version available, and build 
   LLVM if it is not.

--thrust=[build|system]
   Use the cub/thrust in the CUDA SDK if 'system' is given; otherwise, it
   downloads a recent version. By default, it detects the thrust version available, and
   download cub and thrust if it is not.

--blas=[openblas|openblas-system|atlas-system|mkl]
   Build OpenBLAS if 'openblas' is given, or use the system OpenBLAS, ATLAS, or MKL if
   'openblas-system', 'atlas-system', 'mkl' is given, respectively. If using MKL, plase
   set the environ variable MKLROOT. By default, it detects if there are flags in LDFLAGS
   and LIBS suggesting the use of MKL, OpenBLAS, and ATLAS, and use that. Otherwise, it
   uses MKL if MKLROOT is set, or OpenBLAS or ATLAS if they have pkg-config sets
   available.

* Compilation flags:
Control the flags use for building the packages.

-g|-O|-Onone
   Append '-g3 -O0' to CFLAGS and CXXFLAGS if '-g' is given, of '-O3' if '-O' is given, 
   or no flags are added if '-Onone' is given. By default, '-O3' is appended.

--avx512
   Append flags in CFLAGS and CXXFLAGS to activate AVX512 extensions in the compiler,
   and set the QphiX isa=avx512. No AVX512 extension is set by default and QPhiX is built
   with isa=avx2.

--knl
   Append flags in CFLAGS and CXXFLAGS to activate KNL and AVX512 extensions in the
   compiler, and set the QphiX isa=avx512. No AVX512 extension is set by default and
   QPhiX is built with isa=avx2.

--std=c++11|c++14|c++20   
   Append the given flag to CXXFLAGS; --std=c++20 is appended if flag '--hip' is set;
   Otherwise, --std=c++14 is appended by default.

--autoflags=no
   If given, CFLAGS, CXXFLAGS, and LDFLAGS are not modified by the options -g, -O,
   --avx512, --knl, and --std, or any automatic heuristic in this script. By default,
   besides setting CFLAGS and CXXFLAGS as described, flags are added to activate AVX2 and
   OpenMP compiler extensions.

* Actions and packages:
An action is either of the flags --clean, --install, or --update, and can be followed by
several packages and other actions. The --update action is implied if no other action was
given before. For instance:

  chromaform chroma --install openblas

marks the package chroma with the flag --update and the package openblas with the flag
--install. The actions are described in the following:

--install <pkg> <pkg> ...
   Always download the source code, build, and install the packages marked with this
   action. Mark their dependent packages as --update.
--update <pkg> <pkg> ...
   Download the source code if it is not in the source directory already, and install the
   packages marked with this action if they are not found on the install directory.
   Mark their dependent packages as --update.
--clean <pkg> <pkg> ...
   Remove the instances in the source, build, and install directories of the packages
   marked with this action.

--download-only
   If given, no building nor installation is done, only changes on the source directory
   are going to be performed. This is useful to download all the sources required and
   copy them to a machine without external internet access. 

* Set environ variables:
All input options that are not flags or packages described above and contain '='
will be considered a variable assignation. For instance:

  chromaform chroma CC=icc CXX=icpc PATH=/mypaths:\$PATH

will export the value of the variables CC, CXX, and PATH to subshells and executed
commands.
EOF

srcdir="src"
builddir="build"
installdir="install"
download_only="nop"
do_cleaning="nop"
use_float="nop"
use_arch="cpu"
use_avx512="nop"
use_pdf="nop"
use_next="nop"
use_mg="nop"
use_llvm=""
use_thrust=""
use_blas=""
use_cmake=""
use_autoflags="yes"
use_opt="opt"
use_knl="nop"
use_std=""
action="update"

# Jean Zay's frontend does not have much memory and chroma linking fails often
mymake() {
	make "$@" || make "$@" -j 1 || make "$@" -j 1 || make "$@" -j 1 
}

MYMAKE="${MAKE:-mymake}"
[ x${MAKE_JN}x == xx ] && MAKE_JN="$(( (`grep "^processor" /proc/cpuinfo | wc -l` + 2) / 3 ))"
[ x${CUDADIR}x == xx ] && CUDADIR="$( realpath $( dirname $( which nvcc ))/..)"
SM="${SM:-sm_70}"
AMDGPU_TARGETS="${AMDGPU_TARGETS:-gfx900;gfx906;gfx908}"
tmp="`mktemp -d`"
idir=""

finish() {
	rm -rf $tmp
	# If a make install failed in the middle, remove the whole directory
	[ x${idir}x != xx ] && rm -rf $idir
}
trap finish EXIT

n=$#
for (( i=1 ; i<=n ; ++i )); do
	arg="$1"
	case $arg in
	--source-dir=*) srcdir="${arg#--source-dir=}";;
	--build-dir=*) builddir="${arg#--build-dir=}";;
	--install-dir=*) installdir="${arg#--install-dir=}";;
	--download-only) download_only="yes";;
	--float) use_float="yes";;
	--cpu) use_arch="cpu";;
	--jit|--cuda) use_arch="cuda";;
	--hip) use_arch="hip";;
	--avx512) use_avx512="yes";;
	--mg) use_mg="yes";;
	--next) use_next="yes";;
	--clean) action="clean";do_cleaning="yes";;
	--install) action="install";;
	--update) action="update";;
	--llvm=build) use_llvm="llvm";;
	--llvm=system) use_llvm="llvm-system";;
	--thrust=build) use_thrust="thrust";;
	--thrust=system) use_thrust="thrust-system";;
	--cmake=build) use_cmake="cmake";;
	--cmake=system) use_cmake="cmake-system";;
	--blas=openblas) use_blas="openblas";;
	--blas=openblas-system) use_blas="openblas-system";;
	--blas=atlas-system) use_blas="atlas-system";;
	--blas=mkl) use_blas="mkl-system";;
	--autoflags=no) use_autoflags="nop";;
	--autoflags=yes) use_autoflags="yes";;
	-g) use_opt="debug";;
	-O) use_opt="opt";;
	-Onone) use_opt="nop";;
	--knl) use_knl="yes"; use_avx512="yes";;
	--c++11) use_std="c++11";;
	--c++14) use_std="c++14";;
	--c++20) use_std="c++20";;
	openblas) openblas="$action";;
	cmake) cmake="$action";;
	llvm) llvm="$action";;
	cub) cub="$action";;
	thrust) thrust="$action";;
	qmp) qmp="$action";;
	qdp) qdp="$action";;
	superbblas) superbblas="$action";;
	qphix) qphix="$action";;
	primme) primme="$action";;
	mgproto) mgproto="$action";;
	quda) quda="$action";;
	mugiq) mugiq="$action";;
	chroma) chroma="$action";;
	laplace_eigs) laplace_eigs="$action";;
	adat) adat="$action";;
	colorvec) colorvec="$action";;
	tensor) tensor="$action";;
	hadron) hadron="$action";;
	harom) harom="$action";;
	redstar) redstar="$action";;
	*=*) export ${arg%%=*}="${arg#*=}";;
	--help|-h) echo "$hlp_msg"; exit 0;;
	*) echo "Sorry! Unsupported option '$arg'"; echo "$hlp_msg"; exit 1;;
	esac
	shift
done

# Prompting

last_status=0 # Last command status
run() {
	echo "$>" "$@"
	"$@" < /dev/null
	last_status=$?
	if [ $last_status -ne 0 ]; then
		echo "$> last command failed with exit status $last_status"
		exit $last_status
	fi
	return 0
}

info() {
	echo "#>" "$@"
}

check_success() {
	echo "Exit status $last_status"
	[ $last_status -ne 0 ] && exit $last_status
}


# Set default compilers

CC="${CC:-mpicc}"
CXX="${CXX:-mpicxx}"

# Add extra flags

if [ x${use_std}x == xx ]; then
	use_std="c++14"
	[ $use_arch == hip ] && use_std="c++20"
	[ $use_arch == cuda -a $use_next == nop ] && use_std="c++20"
fi

detect_compiler() {
	compiler="any"
	if ( $CXX -v 2>&1 | grep -q '^gcc version' ); then
		compiler="gcc"
	elif ( $CXX -v 2>&1 | grep -q '^clang version' ); then
		compiler="clang"
	elif ( $CXX -v 2>&1 | grep -q '^icc version' ); then
		compiler="icc"
	elif ( $CXX -v 2>&1 | grep -q '^icpc version' ); then
		compiler="icc"
	fi
	echo $compiler
}

if [ ${use_autoflags} == yes ]; then
	if [ ${use_knl} == yes ]; then
		# Active special tricks for a special architecture
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xCORE-AVX2 -axCORE-AVX512,MIC-AVX512"
			CFLAGS+=" -xCORE-AVX2 -axCORE-AVX512,MIC-AVX512"
			;;
		*)
			CXXFLAGS+=" -march=knl -mavx512f -mavx512pf -mavx512er -mavx512cd"
			CFLAGS+=" -march=knl -mavx512f -mavx512pf -mavx512er -mavx512cd"
			;;
		esac
		use_avx512="yes"
	elif [ ${use_avx512} == yes ]; then
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xCORE-AVX2 -axCORE-AVX512"
			CFLAGS+=" -xCORE-AVX2 -axCORE-AVX512"
			;;
		*)
			CXXFLAGS+=" -march=skylake-avx512 -mavx512f -mavx512pf -mavx512er -mavx512cd"
			CFLAGS+=" -march=skylake-avx512 -mavx512f -mavx512pf -mavx512er -mavx512cd"
			;;
		esac
	elif grep -q "cpu.*:.*POWER" /proc/cpuinfo ; then
		echo Detected POWER architecture, no specific architecture flags set
	else
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -xCORE-AVX2"
			CFLAGS+=" -xCORE-AVX2"
			;;
		*)
			CXXFLAGS+=" -march=haswell -mavx2"
			CFLAGS+=" -march=haswell -mavx2"
			;;
		esac
	fi
	if ! ( echo ${CXXFLAGS} | grep -q openmp ); then
		# QDP is compiled with OpenMP, so we need to add the flag
		case "`detect_compiler`" in
		icc)
			CXXFLAGS+=" -qopenmp"
			CFLAGS+=" -qopenmp"
			LDFLAGS+=" -qopenmp"
			;;
		*)
			CXXFLAGS+=" -fopenmp"
			CFLAGS+=" -fopenmp"
			LDFLAGS+=" -fopenmp"
			;;
		esac
	fi
	case ${use_opt} in
	debug)
		CFLAGS+=" -g3 -O0"
		CXXFLAGS+=" -g3 -O0"
		LDFLAGS+=" -g3 -O0"
		;;
	opt)
		CFLAGS+=" -O3"
		CXXFLAGS+=" -O3"
		LDFLAGS+=" -O3"
		;;
	esac
	CXXFLAGS+=" -std=$use_std"
	# Old versions of icc need this
	CFLAGS+=" -std=c99"
fi

# If the user gives BLAS options LDFLAGS or LIBS, use them.
# Otherwise, try to detect an available BLAS on the system,
# or compile OpenBLAS

if [ x${use_blas}x == xx ]; then
	info "No BLAS suggestion give; detecting BLAS..."
	case "$LDFLAGS $LIBS" in
	*libmkl*|*-mkl*) use_blas="mkl-system";;
	*openblas*) use_blas="openblas-system";;
	*atlas*) use_blas="atlas-system";;
	*)
		if [ x${openblas}x != xx ]; then
			use_blas="openblas"
		elif [ x${MKLROOT}x != xx ]; then
			use_blas="mkl-system"
			CFLAGS+=" -I${MKLROOT}/include"
			CXXFLAGS+=" -I${MKLROOT}/include"
			LIBS+=" -L${MKLROOT}/lib/intel64 -Wl,--no-as-needed -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core -liomp5 -lpthread -lm -ldl"
		elif pkg-config --cflags openblas ; then
			use_blas="openblas-system"
			CFLAGS+=" `pkg-config --cflags openblas`"
			CXXFLAGS+=" `pkg-config --cflags openblas`"
			LIBS+=" `pkg-config --libs openblas`"
		elif pkg-config --cflags atlas ; then
			use_blas="atlas-system"
			CFLAGS+=" `pkg-config --cflags atlas`"
			CXXFLAGS+=" `pkg-config --cflags atlas`"
			LIBS+=" `pkg-config --libs atlas`"
		else
			use_blas="openblas"
		fi
	;;
	esac
fi

# Detect if there is a cmake available in case the user does not give a clue

if [ x${use_cmake}x == xx ]; then
	info "No cmake suggestion given; detecting cmake version..."
	use_cmake="cmake"
	if cmake --version &> /dev/null ; then
		cmake_version="`cmake --version 2>&1  | grep "^cmake version" | tr . ' '`"
		ver_maj="`echo $cmake_version | while read a a ver_maj ver_minor a ; do echo $ver_maj; done`"
		ver_minor="`echo $cmake_version | while read a a ver_maj ver_minor a ; do echo $ver_minor; done`"
		[ $(( ver_maj >= 3 && ver_minor >= 13 )) -eq 1 ] && use_cmake="cmake-system"
	fi
fi

# Add hipconfig -l into the PATH

if [ $use_arch == hip ]; then
	[ x${HIPCONFIG}x == xx ] && HIPCONFIG="$( which hipconfig )"
	export PATH="$PATH:`$HIPCONFIG -l`"
fi

# Detect if there is a LLVM available in case the user does not give a clue

if [ x${use_llvm}x == xx ]; then
    if [ x${llvm}x != xx ]; then
        use_llvm="llvm"
    elif llvm-config --version &> /dev/null ; then
        llvm_ver="`llvm-config --version`"
        case $llvm_ver in
	12*|13*) use_llvm="llvm-system" ;;
        *)       use_llvm="llvm";;
        esac
    else
        use_llvm="llvm"
    fi
fi

# Detect if there is a cub/thrust available in case the user does not give a clue
# Also thrust versions previous to CUDA 11 (thrust version < 1.9.10) may fail.
# Since SDK CUDA 11, cub is also distributed. So, if cub is present, the thrust on
# the SDK is good enough

if [ x${use_thrust}x == xx ]; then
	if [ x${thrust}x != xx ]; then
		use_thrust="thrust"
	elif [ $use_arch == hip ]; then
		use_thrust="thrust"
	elif [ -d $CUDADIR/targets/x86_64-linux/include/cub -a -d $CUDADIR/targets/x86_64-linux/include/thrust ]; then
		use_thrust="thrust-system"
	else
		use_thrust="thrust"
	fi
fi

# Print basic variables

info "Using PATH: $PATH"
info "Using CUDADIR: $CUDADIR"
info "Using cmake: ${use_cmake}"
info "Using llvm: ${use_llvm}"
info "Using thrust: ${use_thrust}"
info "Using BLAS: ${use_blas}"
info "Using CC=$CC"
info "Using CFLAGS=$CFLAGS"
info "Using CXX=$CXX"
info "Using CXXFLAGS=$CXXFLAGS"
info "Using FC=$FC"
info "Using LDFLAGS=$LDFLAGS"
info "Using LIBS=$LIBS"
export CC CFLAGS CXX CXXFLAGS FC LDFLAGS LIBS

# Process dependencies

if [ $use_arch == cpu ]; then
	[ $use_mg == yes -a x${chroma}x != xx ] && mgproto="${mgproto:-update}"
	[ x${mgproto}x != xx ] && qphix="${qphix:-update}"
	[ $use_next == yes -a x${mgproto}x != xx ] && primme="${primme:-update}"
else
	[ $use_mg == yes -a x${chroma}x != xx ] && quda="${quda:-update}"
	#[ $use_mg == yes -a $use_next == yes ] && mugiq="${mugiq:-update}"
fi
[ x${quda}x != xx -a $use_arch == hip ] && cpm="${cpm:-update}"
[ x${mugiq}x != xx ] && quda="${quda:-update}"
[ x${chroma}x != xx ] && superbblas="${superbblas:-update}"
[ x${mgproto}x != xx ] && primme="${primme:-update}"
[ x${qphix}${mgproto}${quda}${chroma}${laplace_eigs}x != xx ] && qdp="${qdp:-update}"
[ x${qphix}${quda}x != xx ] && eigen="${eigen:-update}"

[ x${laplace_eigs}x != xx ] && primme="${primme:-update}"
[ x${redstar}x != xx ] && hadron="${hadron:-update}" && adat="${adat:-update}" && colorvec="${colorvec:-update}"
[ x${colorvec}x != xx ] && hadron="${hadron:-update}" && adat="${adat:-update}"
[ x${harom}x != xx ] && hadron="${hadron:-update}" && qdp="${qdp:-update}"
[ x${hadron}x != xx ] && tensor="${tensor:-update}"
[ x${qdp}x != xx ] && qmp="${qmp:-update}"

[ $use_arch == cuda -a x${qdp}x != xx -a $use_llvm == llvm ] && llvm="${llvm:-update}"
[ x${tensor}x != xx -a $use_blas == openblas ] && openblas="${openblas:-update}"
[ x${primme}x != xx -a $use_blas == openblas ] && openblas="${openblas:-update}"
[ x${superbblas}x != xx -a $use_blas == openblas ] && openblas="${openblas:-update}"
if [ $use_blas != openblas -a x${openblas}x != xx ]; then
	echo "Incompatible options: --blas!=openblas but also asking for compiling openblas"
	exit 1
fi
if [ $use_arch != cpu -a x${laplace_eigs}${harom}x != xx ]; then
	echo "Incompatible options: --jit cannot be use while targeting laplace_eigs or harom"
	exit 1
fi
[ $use_arch != cpu -a x${superbblas}${quda}x != xx -a $use_thrust == thrust ] && thrust="${thrust:-update}"
[ x${thrust}x != xx -a $use_arch == cuda ] && cub="${cub:-update}"
[ x${thrust}x != xx -a $use_arch == hip ] && prim="${prim:-update}"
if [ $use_thrust != thrust -a x${thrust}x != xx ]; then
	echo "Incompatible options: --thrust=system but also asking for compiling thrust"
	exit 1
fi

[ x${llvm}${qphix}${mgproto}${quda}${mugiq}x != xx -a $use_cmake == cmake ] && cmake="${cmake:-update}"

# Download

mkdir -p $srcdir
srcdir="`realpath $srcdir`"
info "Source directory: $srcdir"

if [ x${qmp}x != xx ]; then
	qmp_src="qmp"
fi
if [ x${qdp}x != xx ]; then
	qdp_src="qdpxx"
	[ $use_arch == cuda -a $use_next == yes ] && qdp_src="qdp-jit-no-concepts"
	[ $use_arch == cuda -a $use_next != yes ] && qdp_src="qdp-jit"
	[ $use_arch == hip ] && qdp_src="qdp-jit"
fi
if [ x${quda}x != xx ]; then
	quda_src="quda"
	[ $use_arch == hip ] && quda_src="quda-hip"
	cpm_src="cpm"
	#[ $use_next == yes ] && quda_src="quda-mugiq"
fi
if [ x${mugiq}x != xx ]; then
	mugiq_src="mugiq"
fi
if [ x${qphix}x != xx ]; then
	qphix_src="qphix"
fi
if [ x${mgproto}x != xx ]; then
	mgproto_src="mgproto"
fi
if [ x${chroma}x != xx ]; then
	chroma_src="chroma"
	[ $use_next == yes -a $use_arch != hip ] && chroma_src="chroma2"
fi
if [ x${primme}x != xx ]; then
	primme_src="primme"
fi
if [ x${cmake}x != xx ]; then
	cmake_src="cmake"
fi
if [ x${llvm}x != xx ]; then
	[ $use_arch == cuda ] && llvm_src="llvm-11"
	[ $use_arch == hip ] && llvm_src="llvm-13"
fi
if [ x${cub}x != xx ]; then
	cub_src="cub"
fi
if [ x${prim}x != xx ]; then
	prim_src="rocPRIM"
fi
if [ x${thrust}x != xx ]; then
	[ $use_arch == cuda ] && thrust_src="thrust"
	[ $use_arch == hip ] && thrust_src="rocThrust"
fi
if [ x${openblas}x != xx ]; then
	openblas_src="openblas"
fi
if [ x${eigen}x != xx ]; then
	eigen_src="eigen"
fi
if [ x${superbblas}x != xx ]; then
	superbblas_src="superbblas"
fi
if [ x${adat}x != xx ]; then
	adat_src="adat"
	[ $use_pdf == yes ] && adat_src="adat-pdf"
fi
if [ x${colorvec}x != xx ]; then
	colorvec_src="colorvec"
	[ $use_pdf == yes ] && colorvec_src="colorvec-pdf"
	[ $use_next == yes ] && colorvec_src="colorvec2"
	if [ $use_next == yes -a $use_pdf == yes ]; then
		echo "Unsupported options: --pdf and --next for colorvec"
		exit 1
	fi
fi
if [ x${tensor}x != xx ]; then
	tensor_src="tensor"
fi
if [ x${hadron}x != xx ]; then
	hadron_src="hadron"
fi
if [ x${harom}x != xx ]; then
	harom_src="harom"
fi
if [ x${redstar}x != xx ]; then
	redstar_src="redstar"
	[ $use_pdf == yes ] && redstar_src="redstar-pdf"
	[ $use_next == yes ] && redstar_src="redstar2"
	if [ $use_next == yes -a $use_pdf == yes ]; then
		echo "Unsupported options: --pdf and --next for redstar"
		exit 1
	fi
fi
if [ x${laplace_eigs}x != xx ]; then
	laplace_eigs_src="laplace_eigs"
fi

cat << EOF | while read act proj
$cmake        $cmake_src
$llvm         $llvm_src
$cub          $cub_src
$prim         $prim_src
$thrust       $thrust_src
$openblas     $openblas_src
$eigen        $eigen_src
$primme       $primme_src
$qmp          $qmp_src
$qdp          $qdp_src
$qphix        $qphix_src
$mgproto      $mgproto_src
$superbblas   $superbblas_src
$mugiq        $mugiq_src
$quda         $quda_src
$cpm          $cpm_src
$chroma       $chroma_src
$laplace_eigs $laplace_eigs_src
$adat         $adat_src
$colorvec     $colorvec_src
$tensor       $tensor_src
$hadron       $hadron_src
$harom        $harom_src
$redstar      $redstar_src
EOF
do
        cat << EOF | while read name repo branch
qdpxx                  https://github.com/usqcd-software/qdpxx         devel
qdp-jit                https://github.com/JeffersonLab/qdp-jit         devel
qdp-jit-no-concepts    https://github.com/eromero-vlc/qdp-jit          no-concepts
qmp                    https://github.com/usqcd-software/qmp           devel
chroma                 https://github.com/JeffersonLab/chroma          devel
chroma2                https://github.com/JeffersonLab/chroma          eloy/superb
qphix                  https://github.com/JeffersonLab/qphix           devel
mgproto                https://github.com/JeffersonLab/mg_proto        devel
harom                  https://github.com/JeffersonLab/harom           devel
hadron                 https://github.com/JeffersonLab/hadron          devel
tensor                 https://github.com/JeffersonLab/tensor          master
redstar                https://github.com/JeffersonLab/redstar         devel
redstar2               https://github.com/JeffersonLab/redstar         eloy/hadron-node-lib
redstar-pdf            https://github.com/JeffersonLab/redstar         devel-pdf
adat                   https://github.com/JeffersonLab/adat            devel
adat-pdf               https://github.com/JeffersonLab/adat            devel-pdf
colorvec               https://github.com/JeffersonLab/colorvec        devel
colorvec-pdf           https://github.com/JeffersonLab/colorvec        devel-pdf
colorvec2              https://github.com/JeffersonLab/colorvec        eloy/hadron-node-lib
laplace_eigs           https://github.com/JeffersonLab/laplace_eigs    devel
primme                 https://github.com/primme/primme                master
superbblas             https://github.com/eromero-vlc/superbblas       master
quda                   https://github.com/lattice/quda                 v1.0.0
quda-hip               https://github.com/lattice/quda                 feature/hip-compile-fixes
mugiq                  https://github.com/eromero-vlc/mugiq            master
#mugiq                  https://github.com/ckallidonis/mugiq            master
quda-mugiq             https://github.com/ckallidonis/quda             CK-MGDeflate
eigen                  https://gitlab.com/libeigen/eigen/-/archive/3.3.9/eigen-3.3.9.tar.bz2
cmake                  https://github.com/Kitware/CMake/releases/download/v3.20.0/cmake-3.20.0.tar.gz
llvm-11                https://github.com/llvm/llvm-project/releases/download/llvmorg-11.1.0/llvm-11.1.0.src.tar.xz
llvm-13                https://github.com/llvm/llvm-project/releases/download/llvmorg-13.0.0-rc2/llvm-13.0.0rc2.src.tar.xz
cub                    https://github.com/NVIDIA/cub/archive/refs/tags/1.12.0.tar.gz
thrust                 https://github.com/NVIDIA/thrust/archive/refs/tags/1.12.0.tar.gz
rocThrust              https://github.com/ROCmSoftwarePlatform/rocThrust/archive/refs/tags/rocm-4.3.1.tar.gz
rocPRIM                https://github.com/ROCmSoftwarePlatform/rocPRIM/archive/refs/tags/rocm-4.3.1.tar.gz
openblas               https://github.com/xianyi/OpenBLAS/releases/download/v0.3.13/OpenBLAS-0.3.13.tar.gz
cpm                    https://github.com/cpm-cmake/CPM.cmake/archive/refs/tags/v0.32.1.tar.gz
EOF
	do
		[ x${proj}x != x${name}x ] && continue
		[ x${act}x == xupdatex -a -d $srcdir/$proj ] && continue
		if [ $do_cleaning == yes ]; then
			[ x${act}x == xclean -a -d $srcdir/$proj ] && rm -f $srcdir/$proj
			continue
		fi
		info "Downloading $proj"
		run rm -rf $srcdir/$proj $tmp/{d,d.zip,d.bz2,d.xz,d.gz}
		case $repo in
		*zip) mkdir $tmp/d && run wget -q "$repo" -O $tmp/d.zip && unzip $tmp/d.zip -d $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*bz2) mkdir $tmp/d && run wget -q "$repo" -O $tmp/d.bz2 && tar xjf $tmp/d.bz2 -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*gz) mkdir $tmp/d && run wget -q "$repo" -O $tmp/d.gz && tar xzf $tmp/d.gz -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*xz) mkdir $tmp/d && run wget -q "$repo" -O $tmp/d.xz && tar xJf $tmp/d.xz -C $tmp/d && mv $tmp/d/* $srcdir/$proj;;
		*git*) ( GIT_ASKPASS=w run git clone --recursive $repo -b $branch $srcdir/$proj ) || GIT_ASKPASS=w run git clone --recursive ${repo/https:\/\/github.com\//git@github.com:} -b $branch $srcdir/$proj;;
		*) echo "Don't know how to download $repo"; exit 1;;
		esac
		[ $proj == cpm ] && ln -s $srcdir/$proj/cmake/CPM.cmake $srcdir/$proj/CPM_0.32.1.cmake
	done || exit 1
done || exit 1

if [ $download_only == yes ]; then
	if [ $do_cleaning == yes ]; then
		echo "Combining --download-only with --clean actions is meaningless."
		exit 1
	fi
	exit 0
fi

# Installing packages

run mkdir -p $builddir
run mkdir -p $installdir
builddir="`realpath $builddir`"
installdir="`realpath $installdir`"
info "Build directory: $builddir"
info "Install directory: $installdir"

if [ x${cmake}x != xx ]; then
	cmake_install="cmake"
	sdir="${srcdir}/${cmake_src}"
	bdir="${builddir}/${cmake_install}"
	idir="${installdir}/${cmake_install}"
	info "Doing ${cmake} cmake; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${cmake} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${cmake} == install -o ! -d ${idir} ]; then
		for i in 0 1; do
			run rm -rf $bdir $idir
			run mkdir -p $bdir
			pushd $bdir
			if [ $i = 0 ] ; then
			       	if cmake --version &> /dev/null; then
					run cmake -DCMAKE_USE_OPENSSL=OFF -DCMAKE_INSTALL_PREFIX=${idir} ${sdir}
					( run ${MYMAKE} -j $MAKE_JN install ) && popd && break
				else
					run $sdir/configure --prefix=$idir
					( run ${MYMAKE} -j $MAKE_JN install ) && popd && break
				fi
			else
				# On some machines, cmake fails to compile excepting with the system compilers
				(
					export CFLAGS=
					export CXXFLAGS=
					run $sdir/configure --prefix=$idir CC=/usr/bin/gcc CXX=/usr/bin/g++
					run ${MYMAKE} -j $MAKE_JN install
				)
			fi
			popd
		done
	fi
	export PATH=$idir/bin:$PATH
fi

if [ x${llvm}x != xx ]; then
	llvm_install="llvm"
	sdir="${srcdir}/${llvm_src}"
	bdir="${builddir}/${llvm_install}"
	idir="${installdir}/${llvm_install}"
	info "Doing ${llvm} LLVM; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${llvm} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${llvm} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run cmake \
		      -DLLVM_ENABLE_TERMINFO="OFF" \
		      -DCMAKE_BUILD_TYPE=Release \
		      -DCMAKE_INSTALL_PREFIX=${idir} \
		      -DLLVM_TARGETS_TO_BUILD="NVPTX;X86" \
		      -DLLVM_ENABLE_ZLIB="OFF" \
		      -DBUILD_SHARED_LIBS="OFF" \
		      -DLLVM_ENABLE_RTTI="ON"  \
		      $sdir
		run ${MYMAKE} -j $MAKE_JN
		run ${MYMAKE} install
		popd
	fi
	export PATH=$idir/bin:$PATH
	export LD_LIBRARY_PATH=$idir/lib:$LD_LIBRARY_PATH
fi

if [ x${cub}x != xx ]; then
	cub_install="cub"
	sdir="${srcdir}/${cub_src}"
	info "Doing ${cub} CUB; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${cub} == clean ] && rm -rf $sdir
	fi
fi

if [ x${prim}x != xx ]; then
	prim_install="prim"
	sdir="${srcdir}/${prim_src}"
	info "Doing ${prim} prim; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${prim} == clean ] && rm -rf $sdir
	fi
fi

if [ x${thrust}x != xx ]; then
	thrust_install="thrust"
	sdir="${srcdir}/${thrust_src}"
	info "Doing ${thrust} thrust; source=$sdir"
	if [ $do_cleaning == yes ]; then
		[ ${thrust} == clean ] && rm -rf $sdir
	fi
fi

if [ x${openblas}x != xx ]; then
	openblas_install="openblas"
	sdir="${srcdir}/${openblas_src}"
	bdir="${builddir}/${openblas_install}"
	idir="${installdir}/${openblas_install}"
	info "Doing ${openblas} OpenBLAS; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${openblas} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${openblas} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		(
			# Setting CFLAGS avoid Openblas to set proper flags
			unset CFLAGS
			unset CXXFLAGS
			run ${MYMAKE} -C ${sdir} clean
			run ${MYMAKE} -C ${sdir} -j $MAKE_JN
			run ${MYMAKE} -C ${sdir} install PREFIX=${idir}
		)
		popd
	fi
	CFLAGS+=" -I${idir}/include"
	CXXFLAGS+=" -I${idir}/include"
	LIBS+=" ${idir}/lib/libopenblas.a -lm -lpthread"
fi

if [ x${tensor}x != xx ]; then
	tensor_install="tensor"
	sdir="${srcdir}/${tensor_src}"
	bdir="${builddir}/${tensor_install}"
	idir="${installdir}/${tensor_install}"
	info "Doing ${tensor} tensor; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${tensor} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${tensor} == install -o ! -d ${idir} ]; then
		( cd $sdir && run bash autogen.sh )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${hadron}x != xx ]; then
	hadron_install="hadron"
	sdir="${srcdir}/${hadron_src}"
	bdir="${builddir}/${hadron_install}"
	idir="${installdir}/${hadron_install}"
	info "Doing ${hadron} hadron; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${hadron} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${hadron} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-tensor=${installdir}/${tensor_install}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${adat}x != xx ]; then
	adat_install="adat"
	sdir="${srcdir}/${adat_src}"
	bdir="${builddir}/${adat_install}"
	idir="${installdir}/${adat_install}"
	info "Doing ${adat} adat; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${adat} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${adat} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${colorvec}x != xx ]; then
	colorvec_install="${colorvec_src}"
	sdir="${srcdir}/${colorvec_src}"
	bdir="${builddir}/${colorvec_install}"
	idir="${installdir}/${colorvec_install}"
	info "Doing ${colorvec} colorvec; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${colorvec} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${colorvec} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-adat=${installdir}/${adat_install}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qmp}x != xx ]; then
	qmp_install="qmp"
	[ $use_arch == hip ] && qmp_install="qmp-hip"
	sdir="${srcdir}/${qmp_src}"
	bdir="${builddir}/${qmp_install}"
	idir="${installdir}/${qmp_install}"
	info "Doing ${qmp} qmp; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${qmp} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${qmp} == install -o ! -d ${idir} ]; then
		[ $use_arch != hip ] && ( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		if [ $use_arch == cpu ]; then
			run ${sdir}/configure --prefix=${idir} --with-qmp-comms-type=MPI --with-qmp-comms-cflags="" --with-qmp-comms-ldflags="" --with-qmp-comms-libs=""
		else
			run cmake \
				-DCMAKE_INSTALL_PREFIX=${idir} \
				-DBUILD_TESTING=OFF \
				-DQMP_MPI=ON \
				-DQMP_TIMING=OFF \
				${sdir}
		fi
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qdp}x != xx ]; then
	qdp_prec="double"
	[ ${use_float} == yes ] && qdp_prec="single"
	sdir="${srcdir}/${qdp_src}"
	if [ $do_cleaning == nop -a $use_arch == cuda ]; then
		run rm -rf ${tmp}/h
		run mkdir -p ${tmp}/h
		run cp ${CUDADIR}/nvvm/libdevice/libdevice*bc ${tmp}/h/libdevice.bc
		( cd $sdir && run bash ./pack_libdevice.sh ${tmp}/h )
	fi
	qdp_extra=""
	case $use_arch in
	cuda)
		qdp_extra+=" -DQDP_ENABLE_BACKEND=CUDA -DQDP_ENABLE_THRUST_ALIGNMENT=ON"
		;;
	hip)
		qdp_extra+=" -DQDP_ENABLE_BACKEND=ROCM -DGPU_TARGETS=${AMDGPU_TARGETS}"
		;;
	esac
	if [ $use_arch != cpu ]; then
        	case $llvm_ver in
		13*) qdp_extra+=" -DQDP_ENABLE_LLVM13=ON" 
        	esac
	fi

	for qdp_nd in 3 4 ; do
		qdp_install="${qdp_src}-${qdp_prec}-nd${qdp_nd}"
		bdir="${builddir}/${qdp_install}"
		idir="${installdir}/${qdp_install}"
		info "Doing ${qdp} QDP nd=$qdp_nd; source=$sdir build=$bdir install=$idir"
		if [ $do_cleaning == yes ]; then
			[ ${qdp} == clean ] && rm -rf $sdir $bdir $idir
		elif [ ${qdp} == install -o ! -d ${idir} ]; then
			[ $use_arch != hip ] && ( cd $sdir && run autoreconf -f )
			run rm -rf $bdir $idir
			run mkdir -p $bdir
			pushd $bdir
			if [ $use_arch == cpu ]; then
				run ${sdir}/configure \
					--prefix=${idir} \
        				--enable-Nd=$qdp_nd \
				        --enable-parallel-arch=parscalar \
					--enable-precision=${qdp_prec} \
				        --enable-filedb \
					--disable-generics \
				        --enable-parallel-io \
				        --enable-alignment=64 \
					--with-qmp=${installdir}/${qmp_install} \
				        --enable-openmp
			else
				run cmake \
					-DCMAKE_INSTALL_PREFIX=${idir} \
					-DQDP_BUILD_EXAMPLES=OFF \
					-DQDP_PARALLEL_ARCH=parscalar \
					-DQDP_ND=$qdp_nd \
					-DQDP_PRECISION=${qdp_prec} \
					-DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP \
					$qdp_extra \
					${sdir}
			fi
			run ${MYMAKE} install -j $MAKE_JN
			popd
		fi
	done
	qdp_install="${qdp_src}-${qdp_prec}-nd4"
	qdp3d_install="${qdp_src}-${qdp_prec}-nd3"
fi

if [ x${quda}x != xx ]; then
	quda_install="${quda_src}-${qdp_install}"
	sdir="${srcdir}/${quda_src}"
	bdir="${builddir}/${quda_install}"
	idir="${installdir}/${quda_install}"
	info "Doing ${quda} QUDA; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${quda} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${quda} == install -o ! -d ${idir} ]; then
		if [ $use_arch == cuda ]; then
			# Fix minor issues
			run rm -rf $sdir/include/externals/cub
			[ x${cub}x != xx ] && run ln -s ${srcdir}/${cub_src}/cub $sdir/include/externals/cub
		fi
		build_type="DEVEL"
		[ $use_opt == debug ] && build_type="DEBUG"
		if [ $use_arch != hip ]; then
			quda_extra_args="\
				-DQUDA_TARGET_TYPE=CUDA \
				-DQUDA_GPU_ARCH=$SM \
				-DQUDA_QDPJITHOME=${installdir}/${qdp_install} \
				-DQUDA_QMPHOME=${installdir}/${qmp_install} \
				-DQUDA_QIOHOME=${installdir}/${qdp_install} \
				-DQUDA_LIMEHOME=${installdir}/${qdp_install} \
				-DCMAKE_C_COMPILER=${CC} \
				-DCMAKE_CXX_COMPILER=${CXX} \
				-DCMAKE_LINKER=${CXX} \
				-DCMAKE_EXE_LINKER_FLAGS="-L${CUDADIR}" \
			"
		else
			quda_extra_args="\
				-DQUDA_TARGET_TYPE=HIP \
				-DGPU_TARGETS=$AMDGPU_TARGETS \
				-DQDPXX_DIR=${installdir}/${qdp_install}/lib/cmake/QDPXX \
				-DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP \
				-DQIO_DIR=${installdir}/${qdp_install}/lib/cmake/QIO \
				-DCLime_DIR=${installdir}/${qdp_install}/lib/cmake/CLime \
				-DMPI_C_COMPILER=${CC} \
				-DMPI_CXX_COMPILER=${CXX} \
				-DCMAKE_C_COMPILER=hipcc \
				-DCMAKE_CXX_COMPILER=hipcc \
			"
			# Avoid compiling issue in QUDA
			quda_extra_args+=" -DQUDA_OPENMP=OFF"
		fi
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		CPM_SOURCE_CACHE=$srcdir CXXFLAGS="${CXXFLAGS//-std=c++??/}" run cmake  \
			-DQUDA_DIRAC_CLOVER=ON \
			-DQUDA_DIRAC_DOMAIN_WALL=OFF \
			-DQUDA_DIRAC_NDEG_TWISTED_MASS=OFF \
			-DQUDA_DIRAC_STAGGERED=OFF \
			-DQUDA_DIRAC_TWISTED_MASS=OFF \
			-DQUDA_DIRAC_TWISTED_CLOVER=OFF \
			-DQUDA_DIRAC_WILSON=ON \
			-DQUDA_DYNAMIC_CLOVER=OFF \
			-DQUDA_FORCE_GAUGE=OFF \
			-DQUDA_FORCE_HISQ=OFF \
			-DQUDA_GAUGE_ALG=OFF \
			-DQUDA_GAUGE_TOOLS=OFF \
			-DQUDA_INTERFACE_QDPJIT=ON \
			-DQUDA_QDPJIT=ON \
			-DQUDA_INTERFACE_MILC=OFF \
			-DQUDA_INTERFACE_CPS=OFF \
			-DQUDA_INTERFACE_QDP=ON \
			-DQUDA_INTERFACE_TIFR=OFF \
			-DQUDA_MAGMA=OFF	\
			-DQUDA_QMP=ON \
			-DQUDA_QIO=ON \
			-DQUDA_MULTIGRID=ON \
			-DQUDA_MAX_MULTI_BLAS_N=9 \
			-DQUDA_DOWNLOAD_EIGEN=NO \
			-DEIGEN_INCLUDE_DIR=${srcdir}/${eigen_src} \
			-DCMAKE_INSTALL_PREFIX=${idir} \
			-DCMAKE_BUILD_TYPE=$build_type \
			-DQUDA_BUILD_SHAREDLIB=NO \
			-DQUDA_BUILD_ALL_TESTS=OFF \
			$quda_extra_args \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${mugiq}x != xx ]; then
	mugiq_install="${mugiq_src}-${quda_install}"
	sdir="${srcdir}/${mugiq_src}"
	bdir="${builddir}/${mugiq_install}"
	idir="${installdir}/${mugiq_install}"
	info "Doing ${mugiq} mugiq; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mugiq} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mugiq} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		cmake  \
			-DMUGIQ_GPU_ARCH=$SM \
			-DMUGIQ_QUDA=ON \
			-DMUGIQ_QUDA_SOURCE=${srcdir}/${quda_src} \
			-DMUGIQ_QUDA_HOME=${installdir}/${quda_install} \
			-DMUGIQ_MAGMA=OFF       \
			-DCMAKE_COMMS_TYPE=QMP \
			-DMUGIQ_QMP_HOME=${installdir}/${qmp_install} \
			-DMUGIQ_QIO=ON \
			-DMUGIQ_QIO_HOME=${installdir}/${qdp_install} \
			-DMUGIQ_LIME_HOME=${installdir}/${qdp_install} \
			-DCMAKE_INSTALL_PREFIX=${idir} \
			-DCMAKE_BUILD_TYPE=DEVEL \
			-DCMAKE_CXX_COMPILER=${CXX} \
			-DCMAKE_C_COMPILER=${CC} \
			-DCMAKE_LINKER=${CXX} \
			-DCMAKE_EXE_LINKER_FLAGS="-L${CUDADIR}" \
			-DMUGIQ_BUILD_ALL_TESTS=OFF \
			${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${qphix}x != xx ]; then
	qphix_install="${qphix_src}-${qdp_install}"
	[ ${use_avx512} == yes ] && qphix_install="${qphix_src}-avx512"
	qphix_isa="avx2"
	[ ${use_avx512} == yes ] && qphix_isa="avx512"
	sdir="${srcdir}/${qphix_src}"
	bdir="${builddir}/${qphix_install}"
	idir="${installdir}/${qphix_install}"
	info "Doing ${qphix} QPhiX; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${qphix} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${qphix} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run cmake -Disa=${qphix_isa} \
		      -Dhost_cxx=${CXX} \
		      -Dhost_cxxflags="" \
		      -Drecursive_jN=${MAKE_JN} \
		      -DCMAKE_INSTALL_PREFIX=${idir} \
		      -DQDPXX_DIR=${installdir}/${qdp_install} \
		      -Dclover=TRUE \
		      -Dtm_clover=TRUE \
		      -Dcean=FALSE \
		      -Dqdpalloc=FALSE \
		      -Dqdpjit=FALSE \
		      -Dtesting=OFF \
		      -DPYTHON_EXECUTABLE="$( which python3 )" \
		      -DPYTHON_INCLUDE_DIR=/usr/include \
		      -DPYTHON_LIBRARY=/usr/lib \
		      ${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${primme}x != xx ]; then
	primme_install="primme"
	sdir="${srcdir}/${primme_src}"
	bdir="${builddir}/${primme_install}"
	idir="${installdir}/${primme_install}"
	info "Doing ${primme} PRIMME; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${primme} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${primme} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r ${srcdir}/${primme_src} $bdir
		run $MYMAKE -C ${bdir} lib install PREFIX=${idir} -j $MAKE_JN CFLAGS="$CFLAGS -fPIC"
		run cp ${bdir}/lib/libprimme.a ${idir}/lib
	fi
	CFLAGS+=" -I${installdir}/${primme_install}/include"
	CXXFLAGS+=" -I${installdir}/${primme_install}/include"
	LIBS="${installdir}/${primme_install}/lib/libprimme.a $LIBS"
fi

if [ x${superbblas}x != xx ]; then
	superbblas_install="superbblas-cpu"
	[ $use_arch == cuda ] && superbblas_install="superbblas-cuda"
	[ $use_arch == hip ] && superbblas_install="superbblas-hip"
	sdir="${srcdir}/${superbblas_src}"
	bdir="${builddir}/${superbblas_install}"
	idir="${installdir}/${superbblas_install}"
	info "Doing ${superbblas} Superbblas; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${superbblas} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${superbblas} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run cp -r ${srcdir}/${superbblas_src} $bdir
		make_action="install_cpu"
		if [ $use_arch == cuda ]; then
			make_action="install_cuda"
			[ x${thrust}x != xx ] && sb_nvcc_extra="-I${srcdir}/${cub_src} -I${srcdir}/${thrust_src}"
			export NVCCFLAGS="-x cu -arch=$SM $NVCCFLAGS $sb_nvcc_extra"
		elif [ $use_arch == hip ]; then
			make_action="install_hip"
			sb_cxx_extra="-I${srcdir}/${prim_src} -I${srcdir}/${thrust_src}"
			hip_arch_flags="$( for arch in ${AMDGPU_TARGETS//;/ }; do echo -n "--offload-arch=$arch "; done )"
			export HIPFLAGS="`$HIPCONFIG -C` -I`$HIPCONFIG -R`/hipblas/include $hip_arch_flags"
		fi
		[ $use_blas == mkl-system ] && sb_cxx_extra+=" -DSUPERBBLAS_USE_MKL"
		run $MYMAKE -C ${bdir} -j $MAKE_JN  $make_action BUILDDIR=${idir} CXXFLAGS="$CXXFLAGS $sb_cxx_extra"
	fi
	# Add clang openmp dependcy
	[ $use_arch == hip ] && LIBS+=" -L`$HIPCONFIG -l`/../lib -lomp"
fi

if [ x${mgproto}x != xx ]; then
	mgproto_install="${mgproto_src}-${qphix_install}"
	sdir="${srcdir}/${mgproto_src}"
	bdir="${builddir}/${mgproto_install}"
	idir="${installdir}/${mgproto_install}"
	info "Doing ${mgproto} mgproto; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${mgproto} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${mgproto} == install -o ! -d ${idir} ]; then
		case $use_blas in
		mkl*) blas="Intel10_64lp_seq";;
		openblas*) blas="OpenBLAS";;
		atlas*) blas="ATLAS";;
		esac
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		mgproto_extra="-DMG_USE_PRIMME=ON -DPRIMME_HOME=${installdir}/${primme_install}"
		cmake \
		    -DMG_USE_KOKKOS=FALSE \
		    -DMG_USE_QPHIX=TRUE \
		    -DQPHIX_DIR=${installdir}/${qphix_install} \
		    -DMG_QPHIX_COMPRESS12=TRUE \
		    -DMG_QPHIX_SOALEN=4 \
		    -DMG_USE_AVX512=FALSE \
		    -DEigen3_DIR=${srcdir}/${eigen_src} \
		    -DKOKKOS_ENABLE_CUDA=FALSE \
		    -DCMAKE_INSTALL_PREFIX=${idir} \
		    -DQDPXX_DIR=${installdir}/${qdp_install} \
		    -DBLA_STATIC=ON -DBLA_VENDOR=$blas \
		    -DBUILD_TESTING=OFF \
		    -DMG_DEFAULT_LOGLEVEL=DEBUG \
		    -DMG_KOKKOS_USE_NEIGHBOR_TABLE=FALSE \
		     $mgproto_extra \
		     ${sdir}
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${chroma}x != xx ]; then
	if [ $use_mg == nop ]; then
		chroma_install="${chroma_src}-${qdp_install}"
	elif [ $use_arch == cpu ]; then
		chroma_install="${chroma_src}-${mgproto_install}"
	else
		chroma_install="${chroma_src}-${quda_install}"
	fi
	sdir="${srcdir}/${chroma_src}"
	bdir="${builddir}/${chroma_install}"
	idir="${installdir}/${chroma_install}"
	info "Doing ${chroma} chroma; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${chroma} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${chroma} == install -o ! -d ${idir} ]; then
		[ $use_arch != hip ] && ( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		if [ $use_arch == cpu ]; then
			if [ $use_mg == yes ]; then
				chroma_extra="\
			        	--with-qphix-solver=${installdir}/${qphix_install} \
			        	--enable-qphix-solver-arch=${qphix_isa} \
			        	--enable-qphix-solver-soalen=4 \
			        	--disable-qphix-solver-compress12 \
			        	--enable-qphix-solver-inner-type=f \
			        	--enable-qphix-solver-inner-soalen=8 \
			        	--with-mg-proto=${installdir}/${mgproto_install}"
			fi
			[ $use_blas == mkl-system ] && sb_cxx_extra="-DSUPERBBLAS_USE_MKL"
			run ${sdir}/configure \
				--prefix=${idir} \
				--with-qdp=${installdir}/${qdp_install} \
				--with-qmp=${installdir}/${qmp_install} \
				--with-superbblas=${installdir}/${superbblas_install} \
			        --enable-static-packed-gauge \
			        --enable-fused-clover-deriv-loops \
				--enable-lapack=lapack --enable-opt-eigcg \
				$chroma_extra CXXFLAGS="$CXXFLAGS $sb_cxx_extra"
		else
			case $use_blas in
			mkl*) blas="Intel10_64lp";;
			openblas*) blas="OpenBLAS";;
			atlas*) blas="ATLAS";;
			esac

			chroma_extra=""
			[ $use_arch == hip -a $use_mg == yes ] && chroma_extra="\
				-DChroma_ENABLE_QUDA=ON \
				-DQUDA_DIR=${installdir}/${quda_install}/lib/cmake/QUDA \
				"

			run cmake \
				-DCMAKE_INSTALL_PREFIX=${idir} \
				-DCMAKE_EXE_LINKER_FLAGS="$LDFLAGS $LIBS" \
				-DQMP_DIR=${installdir}/${qmp_install}/lib/cmake/QMP \
				-DQDPXX_DIR=${installdir}/${qdp_install}/lib/cmake/QDPXX \
				-DChroma_ENABLE_JIT_CLOVER=ON \
				-DChroma_ENABLE_SUPERBBLAS=ON \
				-DSUPERBBLAS_DIR=${installdir}/${superbblas_install} \
		    		-DBLA_STATIC=ON -DBLA_VENDOR=$blas \
				$chroma_extra \
				${sdir}
		fi
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${harom}x != xx ]; then
	harom_install="harom"
	sdir="${srcdir}/${harom_src}"
	bdir="${builddir}/${harom_install}"
	idir="${installdir}/${harom_install}"
	info "Doing ${harom} harom; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${harom} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${harom} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-qdp=${installdir}/${qdp3d_install} \
			--enable-experimental-baryon-blas-creation
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${redstar}x != xx ]; then
	redstar_install="${redstar_src}"
	sdir="${srcdir}/${redstar_src}"
	bdir="${builddir}/${redstar_install}"
	idir="${installdir}/${redstar_install}"
	info "Doing ${redstar} redstar; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${redstar} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${redstar} == install -o ! -d ${idir} ]; then
		( cd $sdir && run autoreconf -f )
		run rm -rf $bdir $idir
		run mkdir -p $bdir
		pushd $bdir
		[ $use_next == yes ] && redstar_extra="--with-colorvec=${installdir}/${colorvec_install}"
		run ${sdir}/configure --prefix=${idir} --with-hadron=${installdir}/${hadron_install} --with-adat=${installdir}/${adat_install}  $redstar_extra
		run ${MYMAKE} install -j $MAKE_JN
		popd
	fi
fi

if [ x${laplace_eigs}x != xx ]; then
	laplace_eigs_install="laplace_eigs"
	sdir="${srcdir}/${laplace_eigs_src}"
	bdir="${builddir}/${laplace_eigs_install}"
	idir="${installdir}/${laplace_eigs_install}"
	info "Doing ${laplace_eigs} laplace_eigs; source=$sdir build=$bdir install=$idir"
	if [ $do_cleaning == yes ]; then
		[ ${laplace_eigs} == clean ] && rm -rf $sdir $bdir $idir
	elif [ ${laplace_eigs} == install -o ! -d ${idir} ]; then
		run rm -rf $bdir $idir
		run mkdir -p ${idir}
		run cp -r $idir $bdir
		pushd $bdir
		run ${MYMAKE} ARCH="QMP" PRIMME_ENV=${installdir}/${primme_install} QDP_CONFIG_ND3_ENV=${installdir}/${qdp3d_install} QDP_CONFIG_ND4_ENV=${installdir}/${qdp_install} 
		run cp laplace_eigs vecs_combine_4d vecs_combine_3d ${idir}
		popd
	fi
fi

# Everything went ok!
# Avoid removing the last installation by function finish
idir=""
